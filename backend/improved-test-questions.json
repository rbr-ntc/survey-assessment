[
	{
		"id": "doc1",
		"category": "documentation",
		"type": "case",
		"question": "Команда просит документировать новый REST API. С чего начнете?",
		"options": [
			{
				"value": "a",
				"text": "Начну с подробного описания всех методов и структур данных, используя спецификацию OpenAPI для автоматической генерации примеров запросов"
			},
			{
				"value": "b",
				"text": "Проведу серию встреч для выявления всех пользователей системы, построю карту вариантов использования и определю приоритеты документирования через анализ влияния"
			},
			{
				"value": "c",
				"text": "Возьму готовый корпоративный шаблон документирования и адаптирую его под особенности текущего проекта и потребности заинтересованных лиц"
			},
			{
				"value": "d",
				"text": "Применю метод репрезентативной документации через Unified REST Description Layer (URDL) — удобно и визуально"
			},
			{
				"value": "e",
				"text": "Обращусь к тимлиду или бади, чтобы они подсказали с чего начать"
			},
			{
				"value": "f",
				"text": "Я не знаю, что делать"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 2,
			"d": 0,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "doc2",
		"category": "documentation",
		"type": "practical",
		"question": "В документации API нужно описать ошибку 429. Что напишете?",
		"options": [
			{ 
				"value": "a", 
				"text": "Код 429 - клиентская ошибка, означающая превышение допустимого количества запросов в единицу времени согласно установленным ограничениям сервиса" 
			},
			{
				"value": "b",
				"text": "Превышен лимит запросов. Клиенту необходимо снизить частоту обращений к API. Рекомендуется реализовать логику повторных попыток с учетом заголовка Retry-After"
			},
			{
				"value": "c",
				"text": "429 Слишком много запросов. Заголовки ответа: Retry-After (секунды до повтора), X-RateLimit-Limit/Remaining/Reset. Стратегия восстановления: экспоненциальная задержка с начальным интервалом 1с, удвоение до максимум 32с"
			},
			{ 
				"value": "d", 
				"text": "Превышена квота использования API. Требуется реализация адаптивного ограничения запросов на стороне клиента с отслеживанием заголовков лимитов для оптимального использования доступной пропускной способности" 
			},
			{ 
				"value": "e", 
				"text": "429  в нумерологии  указывает на необходимость поиска баланса между стабильной работой и духовным развитием, а также на важность сотрудничества и завершения текущих дел" 
			},
			{ 
				"value": "f", 
				"text": "Затрудняюсь ответить" 
			}
		],
		"weights": { "a": 1, "b": 3, "c": 5, "d": 1, "e": 0, "f": 0 }
	},
	{
		"id": "doc3",
		"category": "documentation",
		"type": "case",
		"question": "Документация устарела на год. Как поступите?",
		"options": [
			{
				"value": "a",
				"text": "Внедрю процесс непрерывного обновления документации с интеграцией в CI/CD пайплайн и проверкой актуальности на основе коммитов"
			},
			{
				"value": "b",
				"text": "Проведу аудит актуальности, опрошу ключевых пользователей, определю приоритеты через матрицу важность/срочность и обновлю критичные разделы с версионированием"
			},
			{
				"value": "c",
				"text": "Переведу документацию в систему управления знаниями на основе событий (event-driven documentation) с поддержкой интеграции в Observability-цепочку"
			},
			{
				"value": "d",
				"text": "Оставлю баннер об устаревании в начале и параллельно обновлю структуру документации с учетом подхода progressive disclosure"
			},
			{
				"value": "e",
				"text": "Проконсультируюсь с тимлидом — он подскажет, что из этого вообще нужно и с чего начать"
			},
			{
				"value": "f",
				"text": "Постепенно сам начну обновлять — пару часов в неделю, как пойдет"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 0,
			"d": 2,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "doc4",
		"category": "documentation",
		"type": "practical",
		"question": "Джуниор спрашивает, что важнее всего в документации. Что ответите?",
		"options": [
			{ 
				"value": "a", 
				"text": "Полнота - документация должна покрывать абсолютно все аспекты системы" 
			},
			{
				"value": "b",
				"text": "Актуальность - лучше меньше документации, но всегда соответствующей текущему состоянию"
			},
			{ 
				"value": "c", 
				"text": "Красивое оформление с диаграммами и скриншотами для лучшего восприятия" 
			},
			{ 
				"value": "d", 
				"text": "Здесь нет единственно правильного ответа - всё зависит от проекта" 
			},
			{ 
				"value": "e", 
				"text": "Понятность - важнее всего, чтобы документация была понятна для всех" 
			},
			{ 
				"value": "f", 
				"text": "Затрудняюсь ответить" 
			}
		],
		"weights": { "a": 2, "b": 5, "c": 2, "d": 3, "e": 2, "f": 0 }
	},
	{
		"id": "doc5",
		"category": "documentation",
		"type": "case",
		"question": "В README.md проекта всего 3 строки. Команда говорит 'код самодокументируемый'. Ваша реакция?",
		"options": [
			{
				"value": "a",
				"text": "Соглашусь — хороший код действительно не требует документации"
			},
			{
				"value": "b",
				"text": "Добавлю минимум: как запустить проект, основные команды, куда обращаться за помощью"
			},
			{
				"value": "c",
				"text": "Создам внутреннюю wiki-страницу вместо README — так проще поддерживать и не мешает коду"
			},
			{
				"value": "d",
				"text": "Затрудняюсь ответить без понимания сложности проекта"
			},
			{
				"value": "e",
				"text": "Напишу полную документацию сам в свободное время"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 1,
			"d": 0,
			"e": 2
		}
	},
	{
		"id": "doc6",
		"category": "documentation",
		"type": "practical",
		"question": "Какой подход или инструмент лучше использовать для документации микросервисов, чтобы удобно поддерживать и развивать систему?",
		"options": [
			{
				"value": "a",
				"text": "Использовать Swagger/OpenAPI для REST-API каждого сервиса и объединить их в общий документационный портал"
			},
			{
				"value": "b",
				"text": "Создать отдельные страницы в Confluence с ручным описанием каждого микросервиса, включая архитектуру и API"
			},
			{
				"value": "c",
				"text": "Хранить основную документацию в README каждого репозитория, дополняя её автоматически генерируемыми диаграммами и примерами использования"
			},
			{
				"value": "d",
				"text": "Нет единого подхода — обычно совмещают несколько инструментов (OpenAPI, Confluence, README), в зависимости от требований команд и стейкхолдеров"
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить — зависит от проекта и команды"
			},
			{
				"value": "f",
				"text": "Обычно для таких задач используют методику 'документационного рендеринга', встроенную в FederationSpec 2.1"
			}
		],
		"weights": {
			"a": 4,
			"b": 2,
			"c": 3,
			"d": 5,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "doc7",
		"category": "documentation",
		"type": "case",
		"question": "В документации старой системы (год без обновлений) нашли неточность, но жалоб от пользователей не было. Какие действия наиболее разумны?",
		"options": [
			{ 
				"value": "a", 
				"text": "Создам задачу с низким приоритетом для технического долга. В будущем запланируем исправления, если раздел снова будет востребован"
			},
			{
				"value": "b",
				"text": "Проверю, насколько часто посещают раздел с неточностью и используют функционал, а потом решу, есть ли смысл тратить ресурсы на исправление"
			},
			{ 
				"value": "c", 
				"text": "Оставлю старое описание без изменений, но добавлю общую пометку в начале раздела, что информация может быть неточной или устаревшей"
			},
			{ 
				"value": "d", 
				"text": "Исправлю только критичные ошибки, способные привести к сбоям или потере данных. Остальные неточности незначительны и не стоят усилий"
			},
			{ 
				"value": "e", 
				"text": "Отправлю письмо всей компании о том, что документация устарела, и буду ждать, кто первый отреагирует"
			},
			{ 
				"value": "f", 
				"text": "Документация устаревает в момент публикации, так что ничего исправлять не нужно"
			},
			{ 
				"value": "g", 
				"text": "Сяду я сразу и исправлю все неточности. Что тянуть то, если я могу сделать это здесь и сейчас?" 
			}
		],
		"weights": { "a": 4, "b": 5, "c": 3, "d": 4, "e": 0, "f": 0, "g": 2 }
	},
	{
		"id": "doc8",
		"category": "documentation",
		"type": "practical",
		"question": "Как грамотно документировать изменения, нарушающие обратную совместимость (breaking changes) в API?",
		"options": [
			{ 
				"value": "a", 
				"text": "Выделю отдельный файл BREAKING_CHANGES.md с примерами старого и нового поведения, ссылками на issue и рекомендациями по переходу"
			},
			{
				"value": "b",
				"text": "Добавлю пометки BREAKING в changelog, подготовлю руководство по миграции и заранее уведомлю пользователей по email и/или в клиентском интерфейсе"
			},
			{ 
				"value": "c", 
				"text": "Обновлю описание API и подменю на портале документации. Разберутся — это же всё равно лучше, чем не обновлять вообще" 
			},
			{ 
				"value": "d", 
				"text": "Уведомлю только активных пользователей через email, потому что это быстрее и проще, чем писать changelog или обновлять гайды"
			},
			{ 
				"value": "e", 
				"text": "Изменения, ломающие совместимость, — это преступление против человечества. В API их не должно быть вообще"
			},
			{ 
				"value": "f", 
				"text": "API ломается, документация — молчит. Кто выживет — тот и мигрирует"
			},
			{ 
				"value": "g", 
				"text": "Честно говоря, я не понимаю, что значит breaking changes и как их документировать"
			}
		],
		"weights": { "a": 4, "b": 5, "c": 1, "d": 2, "e": 1, "f": 0, "g": 0 }
	},
	{
		"id": "doc9",
		"category": "documentation",
		"type": "case",
		"question": "Стейкхолдер жалуется, что документация слишком техническая и непонятна для него. Что делать?",
		"options": [
			{
				"value": "a",
				"text": "Попробую оперативно связаться со стейкхолдером и лично объяснить ему суть документации своими словами, чтобы он понял ключевые моменты без технических деталей"
			},
			{
				"value": "b",
				"text": "Создам отдельный краткий гайд для бизнес-аудитории: с примерами, схемами и описанием целей, без технических подробностей"
			},
			{
				"value": "c",
				"text": "Добавлю ссылки на внешние ресурсы (вики, статьи, видео), чтобы стейкхолдер мог разобраться сам — если захочет"
			},
			{
				"value": "d",
				"text": "Ничего менять не буду: документация предназначена для разработчиков. Попросил бы кого-то из BA объяснить ему устно"
			},
			{
				"value": "e",
				"text": "Обсужу с тимлидом или менеджером, чтобы понять, насколько реально адаптировать документацию под разные роли"
			},
			{
				"value": "f",
				"text": "Вставлю в начало документации дисклеймер: 'Для понимания требуется уровень middle+ и немного магии'"
			},
			{
				"value": "g",
				"text": "Полностью перепишу документацию на более простой язык. Займёт кучу времени, но, возможно, поможет и другим, не только этому стейкхолдеру"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 4,
			"d": 1,
			"e": 1,
			"f": 0,
			"g": 2
		}
	},
	{
		"id": "doc10",
		"category": "documentation",
		"type": "case",
		"question": "Вы должны актуализировать старую документацию, но никто уже не понимает, как API работает. Что делать в первую очередь?",
		"options": [
			{
				"value": "a",
				"text": "Сделаю обратную разработку (reverse engineering): изучу код, старые логи, авто-тесты и шаблоны запросов"
			},
			{
				"value": "b",
				"text": "Попробую вручную отправлять запросы в API и зафиксирую поведение по факту — шаг за шагом, по типу black-box анализа"
			},
			{
				"value": "c",
				"text": "Обсужу с командой: если API никто не понимает, возможно, стоит зафиксировать ограничения и задокументировать только поверхностную информацию"
			},
			{
				"value": "d",
				"text": "Буду ждать, пока вернётся кто-то из старой команды — без этого велика вероятность сделать что-то не так"
			},
			{
				"value": "e",
				"text": "Откажусь от актуализации: без понимания оригинальной логики новая документация может только навредить"
			},
			{
				"value": "f",
				"text": "Начну описывать API по тем кускам, которые понял сам. Если что — потом допишу, когда разберусь дальше"
			}
		],
		"weights": {
			"a": 5,
			"b": 4,
			"c": 3,
			"d": 1,
			"e": 1,
			"f": 2
		}
	},
	{
		"id": "doc11",
		"category": "documentation",
		"type": "case",
		"question": "Из каких разделов должна состоять полноценная техническая документация для новой фичи или решения?",
		"options": [
			{
				"value": "a",
				"text": "Контекст, цели, функциональные и нефункциональные требования, ограничения, архитектурные решения, API-описания, схема данных, план отката, сопровождение"
			},
			{
				"value": "b",
				"text": "Описание цели, архитектура, Partition View, взаимодействие с L2-цепочками, данные нагрузочного прогноза, план хранения логов"
			},
			{
				"value": "c",
				"text": "Контекст, цели, ограничения, список Jira-задач, скриншоты UI, таблица Rollout Impact и объяснение DevRel-метрик"
			},
			{
				"value": "d",
				"text": "Цель, требования, архитектура, схема данных, API, rollback plan, monitoring — но только если используются кастомные сервисы"
			},
			{
				"value": "e",
				"text": "Функциональные и нефункциональные требования, описание взаимодействий, структура API, нотация UML, раздел багов и Known Unknowns"
			},
			{
				"value": "f",
				"text": "Я не совсем понимаю, из чего она должна состоять. Наверное, зависит от того, кто её будет читать — архитектор или разработчик"
			}
		],
		"weights": {
			"a": 5,
			"b": 0,
			"c": 2,
			"d": 4,
			"e": 3,
			"f": 1
		}
	},
	{
		"id": "model1",
		"category": "modeling",
		"type": "case",
		"question": "Вы начинаете проектирование новой системы обработки заказов. Какую диаграмму логично построить первой?",
		"options": [
			{
				"value": "a",
				"text": "Сначала сделаю BPMN-диаграмму ключевых бизнес-процессов, чтобы согласовать с бизнес-заказчиком, как работает обработка заказов"
			},
			{
				"value": "b",
				"text": "Начну с выделения ключевых событий в системе и построю event-driven модель, чтобы очертить предметную область и поведение компонентов"
			},
			{
				"value": "c",
				"text": "Честно — я бы уточнил у тимлида, какую диаграмму у нас в команде обычно делают первой"
			},
			{
				"value": "d",
				"text": "Создам общую архитектурную схему в формате SysML Hybrid Layering с опорой на нотацию CASEFlex для интеграции бизнес- и техпредставлений"
			},
			{
				"value": "e",
				"text": "Построю контекстную диаграмму системы для определения границ, внешних участников и точек интеграции"
			},
			{
				"value": "f",
				"text": "Нарисую сразу базу данных с таблицами заказов, клиентов и статусов — с неё же всё начинается"
			},
			{
				"value": "g",
				"text": "Мне пока не совсем понятно, о чём задача. Нужно больше контекста, чтобы выбрать правильный тип диаграммы"
			}
		],
		"weights": {
			"a": 4,
			"b": 3,
			"c": 1,
			"d": 0,
			"e": 5,
			"f": 2,
			"g": 0
		}
	},
	{
		"id": "model2",
		"category": "modeling",
		"type": "practical",
		"question": "В BPMN-диаграмме нужно показать, что менеджер может одобрить или отклонить заказ. Какой элемент используете?",
		"options": [
			{
				"value": "a",
				"text": "Пользовательская задача с граничными событиями — каждое событие соответствует исходу (одобрение или отказ)"
			},
			{
				"value": "b",
				"text": "Исключающий шлюз (Exclusive Gateway, XOR) после пользовательской задачи — ветки пойдут в зависимости от решения"
			},
			{
				"value": "c",
				"text": "Сложный шлюз, ведь там два исхода и, возможно, появятся ещё"
			},
			{
				"value": "d",
				"text": "Добавлю просто две задачи — 'Одобрение' и 'Отклонение'. Так нагляднее"
			},
			{
				"value": "e",
				"text": "Нарисую подпроцесс внутри задачи менеджера, а уже в нём разветвлю на действия"
			},
			{
				"value": "f",
				"text": "Я бы спросил у тимлида, как это обычно оформляют — вдруг у нас уже есть шаблон"
			},
			{
				"value": "g",
				"text": "Я вообще не понял, что здесь нужно показать. Просто два действия — а в чём вопрос?"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 0,
			"d": 0,
			"e": 2,
			"f": 1,
			"g": 0
		}
	},
	{
		"id": "model3",
		"category": "modeling",
		"type": "case",
		"question": "Stakeholder не понимает техническую диаграмму. Что сделаете?",
		"options": [
			{
				"value": "a",
				"text": "Сделаю краткую выжимку по диаграмме и добавлю к ней кликабельный прототип, чтобы заказчику было проще воспринимать через сценарии"
			},
			{
				"value": "b",
				"text": "Построю двухуровневое представление — техническое и бизнес — с терминами из предметной области и возможностью переключения"
			},
			{
				"value": "c",
				"text": "Попробую пересобрать диаграмму в виде инфографики с метафорами, которые ближе заказчику"
			},
			{
				"value": "d",
				"text": "Проведу отдельную встречу и объясню основные элементы диаграммы, акцентируя на тех, что важны для принятия решений"
			},
			{
				"value": "e",
				"text": "Скажу заказчику, что диаграмма — это для команды, а ему пришлю текстовое резюме"
			},
			{
				"value": "f",
				"text": "Обращусь к аналитику посильнее — возможно, у него уже есть аналогичный пример, который зашёл заказчику"
			},
			{
				"value": "g",
				"text": "Честно говоря, я не до конца понял, что именно он не понял. Нужно больше контекста, чтобы что-то менять"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 2,
			"d": 3,
			"e": 1,
			"f": 2,
			"g": 0
		}
	},
	{
		"id": "model4",
		"category": "modeling",
		"type": "practical",
		"question": "Заказчик просит 'просто нарисовать схему базы данных'. С чего начнете?",
		"options": [
			{
				"value": "a",
				"text": "Открою dbdiagram.io и начну с ключевых сущностей, уточняя детали по ходу — главное, чтобы заказчик видел прогресс"
			},
			{
				"value": "b",
				"text": "Сначала уточню у заказчика, зачем нужна схема: архитектурное планирование, разработка или визуализация бизнес-понятий"
			},
			{
				"value": "c",
				"text": "Построю концептуальную модель, затем логическую и физическую — чтобы покрыть все уровни абстракции"
			},
			{
				"value": "d",
				"text": "Запрошу дамп БД и сделаю реверс-инжиниринг, чтобы хотя бы что-то было — вдруг совпадёт с ожиданиями"
			},
			{
				"value": "e",
				"text": "Сделаю схему из того, что помню по прошлому проекту — если что, потом скажу, что это черновик"
			},
			{
				"value": "f",
				"text": "Попрошу у старшего аналитика пример схемы, которую он уже делал — адаптирую под свой случай"
			},
			{
				"value": "g",
				"text": "Я не совсем понял, какая схема нужна: ER-диаграмма, физическая структура или просто квадратики со стрелочками?"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 4,
			"d": 3,
			"e": 1,
			"f": 1,
			"g": 0
		}
	},
	{
		"id": "model5",
		"category": "modeling",
		"type": "case",
		"question": "На диаграмме последовательности более 50 объектов, и команда жалуется, что в ней невозможно разобраться. Что сделаете?",
		"options": [
			{
				"value": "a",
				"text": "Разобью диаграмму на несколько логических блоков по функциональным областям, добавив переходы между ними"
			},
			{
				"value": "b",
				"text": "Создам обзорную диаграмму с ключевыми сущностями, а детальные представления оформлю отдельно"
			},
			{
				"value": "c",
				"text": "Попробую вручную передвинуть элементы, чтобы визуально стало проще — может, этого уже будет достаточно"
			},
			{
				"value": "d",
				"text": "Добавлю цветовые акценты и выносные пояснения, чтобы лучше ориентироваться в важных фрагментах"
			},
			{
				"value": "e",
				"text": "Предложу рассмотреть другие подходы — например, BPMN или даже просто табличное описание шагов"
			},
			{
				"value": "f",
				"text": "Уточню у команды, где именно затык — может, достаточно скрыть второстепенные объекты или сделать группировку"
			},
			{
				"value": "g",
				"text": "Я не понимаю, почему это проблема. Я делал по стандарту моделирования, который мы используем в компании"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 1,
			"d": 2,
			"e": 3,
			"f": 2,
			"g": 0
		}
	},
	{
		"id": "model6",
		"category": "modeling",
		"type": "practical",
		"question": "Нужно смоделировать асинхронную систему обмена сообщениями между несколькими сервисами. Какую нотацию выберете?",
		"options": [
			{
				"value": "a",
				"text": "UML Sequence Diagram — покажу асинхронные вызовы и возвраты между участниками системы"
			},
			{
				"value": "b",
				"text": "Component Diagram с указанием очередей сообщений, брокеров и направлений потоков данных"
			},
			{
				"value": "c",
				"text": "BPMN — используя события отправки/получения сообщений и промежуточные события в цепочке процессов"
			},
			{
				"value": "d",
				"text": "Использую Hybrid Flow Notation (HFN) — позволяет комбинировать поведение, структуру и события в одной диаграмме"
			},
			{
				"value": "e",
				"text": "Выбор зависит от цели модели: если для архитекторов — подойдёт C4-контейнер, если для бизнеса — BPMN"
			},
			{
				"value": "f",
				"text": "Я не совсем понимаю, что такое асинхронная система и какую диаграмму под неё лучше использовать"
			}
		],
		"weights": {
			"a": 3,
			"b": 4,
			"c": 3,
			"d": 0,
			"e": 5,
			"f": 0
		}
	},
	{
		"id": "model7",
		"category": "modeling",
		"type": "case",
		"question": "Младший аналитик нарисовал диаграмму классов, в которой один класс содержит более 200 методов. Как поступите?",
		"options": [
			{
				"value": "a",
				"text": "Объясню на примерах, как принцип единой ответственности (SRP) помогает упростить поддержку, и покажу, как можно разбить класс"
			},
			{
				"value": "b",
				"text": "Сяду с ним вместе, разберу логику методов, предложу сгруппировать их по смыслу и найти естественные границы для деления"
			},
			{
				"value": "c",
				"text": "Порекомендую книгу вроде 'Чистая архитектура' или 'Refactoring', а также показать подход EventClass Delegation для распределения поведения"
			},
			{
				"value": "d",
				"text": "Если система работает и тесты проходят, значит всё в порядке. Потом как-нибудь разберёмся"
			},
			{
				"value": "e",
				"text": "Использую рекомендацию ISO/IEC 9126 и предложу увеличить глубину иерархии для лучшей декомпозиции"
			},
			{
				"value": "f",
				"text": "Мне сложно оценить, что не так с таким классом — я ещё не работал с UML и диаграммами классов"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 2,
			"d": 1,
			"e": 0,
			"f": 0
		}
	},
	{
		"id": "model8",
		"category": "modeling",
		"type": "practical",
		"question": "Вы готовите визуализацию микросервисной архитектуры. Что важно отразить в первую очередь?",
		"options": [
			{
				"value": "a",
				"text": "Сначала уточню у тимлида, что именно он хочет отобразить, чтобы не тратить время на ненужные детали"
			},
			{
				"value": "b",
				"text": "Покажу взаимодействие между сервисами, используемые протоколы, направления вызовов и возможные точки отказа"
			},
			{
				"value": "c",
				"text": "Добавлю в диаграмму описание связи через ProtoStreamFlow-контроллеры и синхронные bridge-шлюзы"
			},
			{
				"value": "d",
				"text": "Детализирую внутреннюю реализацию каждого микросервиса — классы, модули, методы"
			},
			{
				"value": "e",
				"text": "Сосредоточусь на инфраструктуре — балансировщиках, брокерах сообщений, базах данных, чтобы понять, где могут быть узкие места"
			},
			{
				"value": "f",
				"text": "Я пока не до конца понимаю, чем визуализация архитектуры отличается от схемы компонентов"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 0,
			"d": 1,
			"e": 3,
			"f": 0
		}
	},
	{
		"id": "model9",
		"category": "modeling",
		"type": "practical",
		"question": "Как корректно отобразить на UML-диаграмме, что одна система использует другую, но не управляет её жизненным циклом?",
		"options": [
			{
				"value": "a",
				"text": "Покажу ассоциацию с агрегацией (Aggregation) — это вроде как «имеет, но не владеет полностью»"
			},
			{
				"value": "b",
				"text": "Выберу композицию (Composition), потому что она показывает прочную связь между объектами"
			},
			{
				"value": "c",
				"text": "Использую зависимость (Dependency) — пунктирная стрелка, обозначающая слабую временную связь между сущностями"
			},
			{
				"value": "d",
				"text": "Нарисую обобщение (Generalization), чтобы показать наследование одной системой от другой"
			},
			{
				"value": "e",
				"text": "Выберу связь через EventBridge — это поможет отразить слабую связанность через события"
			},
			{
				"value": "f",
				"text": "Сначала уточню у тимлида — возможно, есть корпоративный шаблон для таких связей"
			},
			{
				"value": "g",
				"text": "Мне сложно понять, в чём разница между ассоциацией и зависимостью"
			}
		],
		"weights": {
			"a": 2,
			"b": 1,
			"c": 5,
			"d": 0,
			"e": 0,
			"f": 1,
			"g": 0
		}
	},
	{
		"id": "model10",
		"category": "modeling",
		"type": "case",
		"question": "Стейкхолдер просит представить сложную техническую модель в виде, понятном нетехническим специалистам. Что лучше сделать?",
		"options": [
			{
				"value": "a",
				"text": "Создам альтернативную версию диаграммы с аналогиями из повседневной жизни и сокращённым количеством элементов"
			},
			{
				"value": "b",
				"text": "Оставлю текущую модель и просто добавлю внизу подробный глоссарий со всеми терминами"
			},
			{
				"value": "c",
				"text": "Переименую все блоки на диаграмме в человекопонятные и добавлю на них эмодзи"
			},
			{
				"value": "d",
				"text": "Сделаю презентацию, где устно объясню смысл диаграммы, чтобы не перегружать визуалом"
			},
			{
				"value": "e",
				"text": "Полностью перепишу модель на языке BusinessSoftML — упрощённой нотации для нетехнических ролей"
			},
			{
				"value": "f",
				"text": "Я не совсем понимаю, что значит 'представить модель'. Лучше бы мне кто-нибудь показал пример"
			}
		],
		"weights": {
			"a": 5,
			"b": 3,
			"c": 1,
			"d": 4,
			"e": 0,
			"f": 0
		}
	},
	{
		"id": "model11",
		"category": "modeling",
		"type": "case",
		"question": "Нужно быстро показать общую архитектуру новой системы руководству. Какой тип диаграммы предпочтительнее?",
		"options": [
			{
				"value": "a",
				"text": "Контекстная диаграмма, которая показывает систему, внешние взаимодействия и границы ответственности"
			},
			{
				"value": "b",
				"text": "Диаграмма последовательности — она визуально красивая, легко объяснить, кто за кем вызывает"
			},
			{
				"value": "c",
				"text": "Диаграмма классов — показывает всё детально, а значит, точно ничего не упустим"
			},
			{
				"value": "d",
				"text": "Диаграмма развертывания — расскажет о серверах и соединениях, а это всегда важно для руководства"
			},
			{
				"value": "e",
				"text": "Сделаю схему в нотации архитектурных контуров — там можно показать уровни и зоны ответственности"
			},
			{
				"value": "f",
				"text": "Я не до конца понимаю, что именно требуется от 'общей архитектуры' — лучше уточню у тимлида"
			}
		],
		"weights": {
			"a": 5,
			"b": 3,
			"c": 2,
			"d": 4,
			"e": 0,
			"f": 0
		}
	},
	{
		"id": "api1",
		"category": "api",
		"type": "practical",
		"question": "Нужно спроектировать API для работы с большими списками (миллионы записей). Какой подход выберете?",
		"options": [
			{ 
				"value": "a", 
				"text": "Сделаю ключевую навигацию по наборам данных (Keyset pagination) с составными индексами и двунаправленными курсорами для согласованности при параллельных изменениях" 
			},
			{
				"value": "b",
				"text": "Реализую курсорную навигацию (Cursor-based pagination), дополнив её метаданными о коллекции и возможностью кешировать позиции для стабильности данных"
			},
			{ 
				"value": "c", 
				"text": "Добавлю параметры offset и limit в URL и увеличу лимит до миллиона — чтобы все точно уместилось" 
			},
			{ 
				"value": "d", 
				"text": "Использую запросы с декларативной выборкой данных и встроенной оптимизацией (GraphQL + Relay-стиль пагинации), чтобы снизить нагрузку на базу" 
			},
			{
				"value": "e",
				"text": "Организую потоковую передачу через серверные события (Server-Sent Events) с периодическим сохранением контрольных точек (checkpoints) и возможностью восстанавливать соединения"
			},
			{
				"value": "f",
				"text": "Воспользуюсь механизмом Resync Index Envelope (RIE), чтобы запрашивать только дельту за последние секунды, не загружая основной канал"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 1,
			"d": 2,
			"e": 3,
			"f": 0
		}
	},
	{
		"id": "api2",
		"category": "api",
		"type": "case",
		"question": "Клиент жалуется на медленный API. Что лучше сделать в первую очередь?",
		"options": [
			{
				"value": "a",
				"text": "Начну с профилирования API: замерю задержки, включу трассировку (tracing) и посмотрю, где именно теряется время"
			},
			{
				"value": "b",
				"text": "Добавлю Redis с TTL 5 минут — наверняка всё из-за отсутствия кеша"
			},
			{
				"value": "c",
				"text": "Проведу нагрузочное тестирование, чтобы проверить, как API ведёт себя при росте нагрузки"
			},
			{
				"value": "d",
				"text": "Перееду на HTTP/3 с поддержкой 0-RTT и включу DNS-push prefetch — должно помочь"
			},
			{
				"value": "e",
				"text": "Сделаю API-ответы короче — может, JSON слишком большой"
			},
			{
				"value": "f",
				"text": "Пойду разбираться сам — сначала логирование, потом в код, потом в базу"
			},
			{
				"value": "g",
				"text": "Пока не знаю, с чего начать — спрошу у тимлида или старших коллег"
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 3,
			"d": 0,
			"e": 1,
			"f": 4,
			"g": 1
		}
	},
	{
		"id": "api3",
		"category": "api",
		"type": "practical",
		"question": "Какой подход лучше использовать для версионирования REST API, чтобы поддерживать старых клиентов и удобно развивать сервис?",
		"options": [
			{
				"value": "a",
				"text": "Оставлю базовый путь /api/ без версий — изменения буду отслеживать по хэдеру `X-API-Level`, который буду обновлять при изменениях"
			},
			{
				"value": "b",
				"text": "Добавлю версию в URL (/api/v1), при этом все версии будут работать параллельно, а миграции опишу в changelog.md"
			},
			{
				"value": "c",
				"text": "Использую MIME-типы в Accept-заголовке (application/vnd.myapi.v2+json), чтобы клиент сам выбирал, какую версию хочет"
			},
			{
				"value": "d",
				"text": "Реализую слой трансформации через API Gateway, который будет адаптировать старые вызовы под новую схему без участия клиента"
			},
			{
				"value": "e",
				"text": "Буду стараться вообще не делать версий: всё новое только через query-параметры вроде `?v=2`, чтобы не ломать совместимость"
			},
			{
				"value": "f",
				"text": "Не сталкивался с этим, скорее всего, обсудил бы с командой и изучил, какие практики уже есть в компании"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 4,
			"d": 3,
			"e": 0,
			"f": 1
		}
	},
	{
		"id": "api4",
		"category": "api",
		"type": "practical",
		"question": "Клиент просит добавить в ответ API новое поле. Как поступите?",
		"options": [
			{ 
				"value": "a", 
				"text": "Добавлю поле в ответ сразу, ведь JSON-клиенты обычно просто игнорируют лишние данные — никаких проблем"
			},
			{
				"value": "b",
				"text": "Проверю влияние на других клиентов, размер ответа и производительность, затем добавлю поле с версионированием или флагом включения, если потребуется"
			},
			{ 
				"value": "c", 
				"text": "Создам новую версию API с этим полем, старую оставлю без изменений, чтобы обеспечить изоляцию изменений"
			},
			{ 
				"value": "d", 
				"text": "Добавлю опциональный параметр запроса `?includeExtraField=true`, чтобы включать поле по требованию"
			},
			{
				"value": "e",
				"text": "Добавлю новое поле в существующее поле `meta`, чтобы не ломать схему — всё же останется внутри одного объекта"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 3,
			"d": 4,
			"e": 1
		}
	},
	{
		"id": "api5",
		"category": "api",
		"type": "case",
		"question": "API возвращает 10МБ JSON на один запрос. Пользователи жалуются. Быстрое решение?",
		"options": [
			{
				"value": "a",
				"text": "Включу gzip-сжатие на сервере — это сразу снизит размер ответа без изменения логики API"
			},
			{
				"value": "b",
				"text": "Добавлю параметры пагинации и фильтрации, чтобы отдавать пользователям только нужные данные"
			},
			{
				"value": "c",
				"text": "Перееду на GraphQL — он позволяет клиенту выбирать только нужные поля, и проблема решится"
			},
			{
				"value": "d",
				"text": "Реализую модуль адаптивной агрегации данных с динамической структурой ответа через Internal Meta Format (IMF)"
			},
			{
				"value": "e",
				"text": "Создам кастомный бинарный протокол вместо JSON, чтобы обеспечить компактность и контроль над сериализацией"
			},
			{
				"value": "f",
				"text": "Спрошу у более опытного разработчика — не уверен, что готов сам принимать такое решение"
			},
			{
				"value": "g",
				"text": "Разобью JSON на части и буду отправлять через несколько последовательных HTTP-запросов вручную с таймаутами"
			},
			{
				"value": "h",
				"text": "Сделаю специальную версию API, которая отдаёт только заголовки данных, а всё остальное по запросу клиента"
			},
			{
				"value": "i",
				"text": "Пока просто разобью JSON на блоки по 2МБ и закодирую их в base64, чтобы избежать таймаутов"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 3,
			"d": 0,
			"e": 1,
			"f": 2,
			"g": 1,
			"h": 4,
			"i": 0
		}
	},
	{
		"id": "api6",
		"category": "api",
		"type": "practical",
		"question": "Как правильно вернуть ошибку валидации в REST API?",
		"options": [
			{
				"value": "a",
				"text": "HTTP 400 с текстом ошибки в теле ответа"
			},
			{
				"value": "b",
				"text": "HTTP 422 с JSON-объектом вида { errors: [ { field: 'name', message: 'обязательное поле' } ] }"
			},
			{
				"value": "c",
				"text": "HTTP 200 с success: false и списком ошибок — фронту ведь главное показать сообщение"
			},
			{
				"value": "d",
				"text": "Выброшу 418 I'm a teapot, чтобы сразу заметили проблему и не игнорировали"
			},
			{
				"value": "e",
				"text": "HTTP 207 Multi-Status с детальным описанием ошибок по каждому полю в массиве"
			},
			{
				"value": "f",
				"text": "Верну HTTP 422, но ошибки зашифрую в base64 и положу в заголовок 'X-Validation-Errors'"
			},
			{
				"value": "g",
				"text": "HTTP 400 с телом в формате application/problem+json, описывающим детали ошибки согласно RFC 7807"
			},
			{
				"value": "h",
				"text": "Нет единого стандарта — главное, чтобы во всех API ошибок был один и тот же формат"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 1,
			"d": 0,
			"e": 2,
			"f": 0,
			"g": 4,
			"h": 4
		}
	},
	{
		"id": "api7",
		"category": "api",
		"type": "case",
		"question": "Нужно реализовать поиск по API. Какой подход выберете для простого проекта?",
		"options": [
			{
				"value": "a",
				"text": "GET /search?q=текст — просто, удобно и покрывает большинство кейсов на старте"
			},
			{
				"value": "b",
				"text": "GET /resources?filter[field]=value — REST-стильно и масштабируется под фильтры"
			},
			{
				"value": "c",
				"text": "POST /search с телом запроса — гибко, но спорно для поисковых запросов с точки зрения идемпотентности"
			},
			{
				"value": "d",
				"text": "Сразу подключу Elasticsearch и сделаю отдельный SearchService с внутренним DSL для условий поиска"
			},
			{
				"value": "e",
				"text": "Добавлю поддержку RSQL или ResonPath, чтобы можно было писать условия в виде query=(name==‘Иван’);(age>30)"
			},
			{
				"value": "f",
				"text": "Пока сложно сказать — сначала надо понять, как пользователи вообще ищут и насколько это критичная фича"
			},
			{
				"value": "g",
				"text": "Оберну API в GraphQL Gateway и буду отдавать поиск как часть схемы с поддержкой вложенных фильтров"
			},
			{
				"value": "h",
				"text": "Посмотрю, как делают в популярных open-source REST API, и повторю на свой лад"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 3,
			"d": 2,
			"e": 0,
			"f": 3,
			"g": 1,
			"h": 2
		}
	},
	{
		"id": "api8",
		"category": "api",
		"type": "practical",
		"question": "Мобильное приложение делает 50 запросов при старте. Как оптимизировать?",
		"options": [
			{
				"value": "a",
				"text": "Реализую батчинг — соберу запросы в один и обработаю на сервере"
			},
			{
				"value": "b",
				"text": "Добавлю endpoint инициализации — один запрос, один ответ, всё нужное"
			},
			{
				"value": "c",
				"text": "Перейду на HTTP/2 — он сам распараллелит и уменьшит накладные расходы"
			},
			{
				"value": "d",
				"text": "Внедрю кеширование на клиенте и сокращу число дублирующихся вызовов"
			},
			{
				"value": "e",
				"text": "Распределю 50 запросов по времени с помощью setTimeout — чтобы не было пиков"
			},
			{
				"value": "f",
				"text": "Добавлю SmartPrefetchLayer с автоопределением нужных данных по сессии"
			},
			{
				"value": "g",
				"text": "Сделаю AutoInitSync: при первом запуске приложение скачает всё, а потом работает из localStorage"
			},
			{
				"value": "h",
				"text": "Пока не знаю, как лучше — обсудил бы с бэкендом, можно ли группировать данные"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 3,
			"d": 3,
			"e": 0,
			"f": 1,
			"g": 2,
			"h": 2
		}
	},
	{
		"id": "api9",
		"category": "api",
		"type": "practical",
		"question": "Клиент жалуется, что при повторной отправке POST запроса создаются дубликаты. Как исправить?",
		"options": [
			{ 
				"value": "a", 
				"text": "Добавлю проверку на существование записи перед созданием новой"
			},
			{
				"value": "b",
				"text": "Реализую идемпотентность через уникальный ключ запроса (Idempotency-Key) с сохранением результатов"
			},
			{ 
				"value": "c", 
				"text": "Переделаю метод на PUT с генерацией UUID на клиенте для естественной идемпотентности"
			},
			{ 
				"value": "d", 
				"text": "Установлю ограничение - один запрос в минуту от одного клиента"
			},
			{ 
				"value": "e", 
				"text": "Использую двухфазный коммит с предварительной резервацией ресурса через токен"
			},
			{ 
				"value": "f", 
				"text": "Включу идемпотентный режим в настройках HTTP сервера"
			},
			{ 
				"value": "g", 
				"text": "POST по определению не идемпотентен, это нормальное поведение"
			},
			{ 
				"value": "h", 
				"text": "Не понимаю, что такое идемпотентность, нужно погуглить"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 4,
			"d": 1,
			"e": 2,
			"f": 0,
			"g": 1,
			"h": 0
		}
	},
	{
		"id": "api10",
		"category": "api",
		"type": "practical",
		"question": "Проектируете API для работы с заказами. Как правильно организовать связанные ресурсы (товары в заказе)?",
		"options": [
			{ 
				"value": "a", 
				"text": "GET /orders/123 — верну заказ со всеми товарами внутри, чтобы упростить клиентскую логику" 
			},
			{
				"value": "b",
				"text": "GET /orders/123 + GET /orders/123/items — отдельный ресурс для товаров, с опцией ?expand=items"
			},
			{ 
				"value": "c", 
				"text": "GET /orders/123/relationships/items — только идентификаторы товаров по JSON:API, без payload" 
			},
			{ 
				"value": "d", 
				"text": "POST /graphql с динамическим выбором вложенности через query-параметры клиента"
			},
			{ 
				"value": "e", 
				"text": "GET /order-items?order_id=123 — отделю товарные позиции как самостоятельный ресурс" 
			},
			{ 
				"value": "f", 
				"text": "GET /orders/123?include=items,items.product,items.product.category — поддержка гибкой вложенности" 
			},
			{ 
				"value": "g", 
				"text": "GET /everything — универсальный endpoint, который возвращает всё, включая пользователей, заказы и товары"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 3,
			"d": 2,
			"e": 4,
			"f": 4,
			"g": 0
		}
	},
	{
		"id": "api11",
		"category": "api",
		"type": "case",
		"question": "Нужно спроектировать API для длительной операции (генерация отчета занимает 5–10 минут). Какой подход выберете?",
		"options": [
			{
				"value": "a",
				"text": "Сделаю обычный POST-запрос и просто увеличу таймаут до 15 минут — если отчёт успеет сгенерироваться, всё сработает"
			},
			{
				"value": "b",
				"text": "POST /reports вернет 202 Accepted с заголовком Location: /reports/{id}/status — пользователь будет проверять статус вручную"
			},
			{
				"value": "c",
				"text": "Открою WebSocket-соединение и буду стримить прогресс отчета в реальном времени"
			},
			{
				"value": "d",
				"text": "Сделаю callback-механизм: клиент укажет свой endpoint, и мы уведомим его по завершении"
			},
			{
				"value": "e",
				"text": "Реализую Server-Sent Events, чтобы клиенту приходили обновления статуса автоматически"
			},
			{
				"value": "f",
				"text": "Сделаю RPC-style API: POST /generateReport и потом polling через GET /checkReportStatus"
			},
			{
				"value": "g",
				"text": "Реализую long polling: клиент делает запрос и ждёт ответа до тех пор, пока отчёт не будет готов"
			},
			{
				"value": "h",
				"text": "Вообще не понимаю, зачем это усложнять — у нас все API работают быстро"
			},
			{
				"value": "i",
				"text": "Не знаю, как правильно решать такие кейсы — сначала бы обсудил с командой или техлидом"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 3,
			"d": 4,
			"e": 3,
			"f": 2,
			"g": 1,
			"h": 0,
			"i": 1
		}
	},
	{
		"id": "api12",
		"category": "api",
		"type": "practical",
		"question": "Как организовать в REST API операцию перевода денег между счетами?",
		"options": [
			{ 
				"value": "a", 
				"text": "PUT /accounts/123/transfer с указанием целевого счета и суммы — ведь PUT означает обновление состояния ресурса" 
			},
			{
				"value": "b",
				"text": "POST /transfers с телом {from: 123, to: 456, amount: 100} — создаётся новая сущность перевода"
			},
			{ 
				"value": "c", 
				"text": "PATCH /accounts/123 — уменьшить баланс, потом PATCH /accounts/456 — увеличить" 
			},
			{ 
				"value": "d", 
				"text": "POST /accounts/123/actions/transfer — логически выделяю действие как операцию" 
			},
			{ 
				"value": "e", 
				"text": "POST /transactions — создаю ресурс типа 'transfer' и даю ему статус (pending, success, failed)" 
			},
			{ 
				"value": "f", 
				"text": "TRANSFER /accounts/123 — специальный HTTP-метод, который точно под это подходит" 
			},
			{ 
				"value": "g", 
				"text": "GraphQL мутация: transferMoney(from: 123, to: 456, amount: 100)" 
			},
			{
				"value": "h",
				"text": "Сначала уточню у бэкенда или архитектора, как у нас заведено — чтобы не нарушить общую архитектуру"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 0,
			"d": 3,
			"e": 4,
			"f": 0,
			"g": 2,
			"h": 1
		}
	},
	{
		"id": "api13",
		"category": "api",
		"type": "case",
		"question": "API должен поддерживать разные форматы ответа (JSON, XML, CSV). Как спроектировать?",
		"options": [
			{ 
				"value": "a", 
				"text": "Разные endpoints: /api/json/users, /api/xml/users, /api/csv/users" 
			},
			{
				"value": "b",
				"text": "Content negotiation через Accept header: application/json, application/xml, text/csv"
			},
			{ 
				"value": "c", 
				"text": "Параметр в URL: /users?format=json или /users.json" 
			},
			{ 
				"value": "d", 
				"text": "Отдельные поддомены: json.api.com, xml.api.com, csv.api.com" 
			},
			{ 
				"value": "e", 
				"text": "Всегда возвращать JSON, клиенты сами конвертируют в нужный формат" 
			},
			{ 
				"value": "f", 
				"text": "POST /convert с указанием исходного формата и целевого" 
			},
			{ 
				"value": "g", 
				"text": "Использовать Protocol Buffers — универсальный бинарный формат" 
			},
			{
				"value": "h",
				"text": "Я ещё не сталкивался с такой задачей, скорее всего, посоветовался бы с более опытными коллегами"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 4,
			"d": 1,
			"e": 1,
			"f": 2,
			"g": 0,
			"h": 0
		}
	},
	{
		"id": "api14",
		"category": "api",
		"type": "practical",
		"question": "Нужно описать в OpenAPI схему, где поле 'notification' может быть либо EmailNotification, либо SmsNotification. Как реализовать полиморфизм?",
		"options": [
			{
				"value": "a",
				"text": "Использовать oneOf с дискриминатором по полю type для выбора схемы"
			},
			{
				"value": "b",
				"text": "Просто сделать type: object без строгой схемы — пусть клиенты сами разбираются"
			},
			{
				"value": "c",
				"text": "Создать общую схему Notification со всеми возможными полями и nullable флагами"
			},
			{
				"value": "d",
				"text": "Использовать allOf для наследования от базовой схемы Notification"
			},
			{
				"value": "e",
				"text": "Применить anyOf без дискриминатора — валидатор сам определит тип"
			},
			{
				"value": "f",
				"text": "OpenAPI не поддерживает полиморфизм, нужно делать разные endpoints"
			},
			{
				"value": "g",
				"text": "Использовать composition через $ref с параметром discriminator.propertyName"
			},
			{
				"value": "h",
				"text": "Сделать два поля: emailNotification и smsNotification, одно будет null"
			},
	    {
				"value": "i",
				"text": "Не знаю, я ещё не описывал такие вещи в OpenAPI"
			}
		],
		"weights": {
			"a": 5,
			"b": 0,
			"c": 2,
			"d": 4,
			"e": 3,
			"f": 0,
			"g": 4,
			"h": 1,
			"i": 0
		}
	},
	{
		"id": "api15",
		"category": "api",
		"type": "practical",
		"question": "Вы проектируете API, который должен выдерживать высокую нагрузку. Какая метрика лучше всего показывает способность системы справляться с большим числом одновременных запросов?",
		"options": [
			{
				"value": "a",
				"text": "RPS (Requests Per Second) — количество запросов, которые система обрабатывает в секунду"
			},
			{
				"value": "b",
				"text": "Latency (задержка) — сколько времени занимает обработка одного запроса"
			},
			{
				"value": "c",
				"text": "CPU Load — загруженность процессора во время пиковых нагрузок"
			},
			{
				"value": "d",
				"text": "Error Rate — процент неудачных или ошибочных запросов"
			},
			{
				"value": "e",
				"text": "Throughput (пропускная способность) — объём данных, обрабатываемый системой за единицу времени"
			},
			{
				"value": "f",
				"text": "Я пока не понимаю, какие метрики на что влияют — нужно почитать"
			}
		],
		"weights": {
			"a": 5,
			"b": 3,
			"c": 2,
			"d": 1,
			"e": 4,
			"f": 0
		}
	},
	{
		"id": "api16",
		"category": "api",
		"type": "case",
		"question": "После запуска новой фичи пользователи жалуются на медленную работу API. Метрики показывают: RPS остался прежним, средняя latency — 300ms, но P95 latency — 2200ms. Что это может означать и что делать?",
		"options": [
			{
				"value": "a",
				"text": "Высокое P95 означает, что небольшая часть запросов сильно тормозит — нужно искать узкие места для тяжёлых кейсов"
			},
			{
				"value": "b",
				"text": "Средняя latency в пределах нормы, значит проблема надуманная — можно игнорировать жалобы"
			},
			{
				"value": "c",
				"text": "RPS не увеличился, значит фича не популярна — оптимизация не приоритетна"
			},
			{
				"value": "d",
				"text": "Это из-за скачков нагрузки — нужно ограничить количество одновременных запросов и ввести rate limiting"
			},
			{
				"value": "e",
				"text": "Надо проверить логи и трассировку: возможно, один из новых endpoints вызывает цепочку внутренних вызовов"
			},
			{
				"value": "f",
				"text": "Пока не знаю, как интерпретировать P95 — стоит уточнить у разработчиков"
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 0,
			"d": 3,
			"e": 4,
			"f": 0
		}
	},
	{
		"id": "api17",
		"category": "api",
		"type": "practical",
		"question": "Какие метрики и ограничения стоит зафиксировать в нефункциональных требованиях к REST API?",
		"options": [
			{
				"value": "a",
				"text": "Ограничения на RPS (requests per second), latency (P95, P99), доступность (uptime 99.9%) и таймауты на отклик"
			},
			{
				"value": "b",
				"text": "Только ограничения на объём ответа и максимальную нагрузку базы данных"
			},
			{
				"value": "c",
				"text": "Уровень покрытия тестами, кодстайл и используемые фреймворки"
			},
			{
				"value": "d",
				"text": "Просто увеличу лимиты на CPU и память — тогда API точно выдержит нагрузку"
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить — не сталкивался с формализацией нефункциональных требований"
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 0,
			"d": 1,
			"e": 0
		}
	},
	{
		"id": "api18",
		"category": "api",
		"type": "practical",
		"question": "Какой способ аутентификации для REST API вы бы выбрали как основной в современном проекте?",
		"options": [
			{
				"value": "a",
				"text": "Basic Auth — просто, стандартно, без лишней сложности"
			},
			{
				"value": "b",
				"text": "OAuth 2.0 с access и refresh токенами — гибко и безопасно"
			},
			{
				"value": "c",
				"text": "JWT токен, передаваемый в куках, с HttpOnly и Secure флагами"
			},
			{
				"value": "d",
				"text": "API ключ, передаваемый в URL-параметре — удобно при отладке"
			},
			{
				"value": "e",
				"text": "Kerberos через SPNEGO — корпоративно и масштабируемо"
			},
			{
				"value": "f",
				"text": "Не знаю, авторизация — это обычно не моя зона ответственности"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 4,
			"d": 1,
			"e": 3,
			"f": 0
		}
	},
	{
    "id": "api19",
    "category": "api",
    "type": "practical",
    "question": "Какой подход обеспечивает безопасное управление access token и refresh token в клиент-серверной архитектуре?",
    "options": [
      {
        "value": "a",
        "text": "Access token хранится в localStorage, refresh token — в cookie с HttpOnly и Secure флагами"
      },
      {
        "value": "b",
        "text": "Оба токена хранятся в URL как параметры запроса, чтобы было видно при отладке"
      },
      {
        "value": "c",
        "text": "Access token — в памяти, refresh token — в защищённой cookie, обновление происходит через silent refresh"
      },
      {
        "value": "d",
        "text": "Refresh token отправляется клиенту вместе с каждым ответом API"
      },
      {
        "value": "e",
        "text": "Не знаю, я обычно использую Basic Auth без токенов"
      }
    ],
    "weights": {
      "a": 4,
      "b": 0,
      "c": 5,
      "d": 1,
      "e": 1
    }
  },
	{
		"id": "api20",
		"category": "api",
		"type": "practical",
		"question": "Реализуете кеширование ответов API. Какую стратегию инвалидации выберете для часто меняющихся данных?",
		"options": [
			{
				"value": "a",
				"text": "TTL 5 минут + событийная инвалидация при изменении данных"
			},
			{
				"value": "b",
				"text": "Cache-Control: no-cache, no-store — кеширование только создаст проблемы"
			},
			{
				"value": "c",
				"text": "ETag с проверкой If-None-Match для условных запросов"
			},
			{
				"value": "d",
				"text": "Stale-while-revalidate — отдаем устаревшие данные пока обновляем кеш"
			},
			{
				"value": "e",
				"text": "Write-through cache — обновляем кеш синхронно при каждой записи"
			},
			{
				"value": "f",
				"text": "Кеширую только неизменяемые данные, остальное без кеша"
			},
			{
				"value": "g",
				"text": "Cache-Tag headers для инвалидации групп связанных объектов"
			},
			{
				"value": "h",
				"text": "Использую blockchain для распределенного кеша с консенсусом"
			},
			{
				"value": "i",
				"text": "Выбор стратегии зависит от бизнес-процесса: для «горячих» данных — частая инвалидация, для «холодных» — длинный TTL или ручной контроль"
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 4,
			"d": 4,
			"e": 3,
			"f": 2,
			"g": 3,
			"h": 0,
			"i": 5
		}
	},
	{
		"id": "api21",
		"category": "api",
		"type": "case",
		"question": "Redis с кешем упал. API начал отдавать 500 ошибки. Как реализовать корректный fallback-механизм, чтобы сохранить работоспособность?",
		"options": [
			{
				"value": "a",
				"text": "Оборачиваю обращение к Redis в try-catch и при ошибке делаю запрос напрямую к БД. Быстро, просто, но может нагружать базу."
			},
			{
				"value": "b",
				"text": "Использую Circuit Breaker (например, Resilience4j) и при сбоях — graceful degradation: читаю напрямую из БД с логированием и алертами."
			},
			{
				"value": "c",
				"text": "Настраиваю реплицированный Redis в режиме hot-standby с ручным переключением при сбоях — помогает только при полной отказоустойчивости."
			},
			{
				"value": "d",
				"text": "Отдаю 503 Service Unavailable — пусть клиент сам повторяет запросы позже. Простой, но плохой UX."
			},
			{
				"value": "e",
				"text": "Дублирую кеш локально (например, в in-memory LRU кэш), чтобы читать из него в случае падения Redis. Быстро, но требует синхронизации."
			},
			{
				"value": "f",
				"text": "Настраиваю Redis Sentinel или кластер с автоматическим failover. Инфраструктурное решение, требует DevOps вовлечения."
			},
			{
				"value": "g",
				"text": "Рассматриваю Redis как критичный компонент. Без него API не должен работать — лучше упасть, чем отдать устаревшие данные."
			},
			{
				"value": "h",
				"text": "Отказываюсь от Redis, использую только локальный кеш в каждом инстансе приложения. Не масштабируется, но уменьшает зависимости."
			},
			{
				"value": "i",
				"text": "Пока не знаю, как такие ситуации обрабатываются, нужно уточнить у команды или почитать про отказоустойчивые архитектуры."
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 2,
			"d": 1,
			"e": 4,
			"f": 3,
			"g": 0,
			"h": 1,
			"i": 0
		}
	},
	{
		"id": "api22",
		"category": "api",
		"type": "practical",
		"question": "Как правильно реализовать cache warming (прогрев кеша) для API при старте нового инстанса или после сброса кеша?",
		"options": [
			{
				"value": "a",
				"text": "Подход 'ленивой инициализации' — кеш наполняется по первому запросу пользователя"
			},
			{
				"value": "b",
				"text": "Фоновый процесс, который прогревает наиболее востребованные данные на основе статистики использования"
			},
			{
				"value": "c",
				"text": "Сразу грузим полный дамп базы в память при старте приложения — пусть будет"
			},
			{
				"value": "d",
				"text": "Использую Blue-Green deployment, где кеш доступен обоим инстансам — минимальные потери"
			},
			{
				"value": "e",
				"text": "SSD быстрые — кеш не нужен, и так всё летает"
			},
			{
				"value": "f",
				"text": "Простой shell-скрипт, который при деплое дергает ключевые endpoints для наполнения кеша"
			},
			{
				"value": "g",
				"text": "Репликация кеша с продакшена в новый инстанс перед переключением трафика — экономит время и нагрузку"
			},
			{
				"value": "h",
				"text": "Предсказание нужных данных на основе ML-модели, обученной на логах обращения"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 0,
			"d": 4,
			"e": 0,
			"f": 3,
			"g": 4,
			"h": 2
		}
	},
	{
		"id": "db1",
		"category": "database",
		"type": "case",
		"question": "В системе есть таблица с 100 млн строк логов. Запросы стали работать медленно. Какое решение наиболее целесообразно для улучшения производительности при ограниченном бюджете?",
		"options": [
			{
				"value": "a",
				"text": "Добавить индекс на все поля, чтобы любой запрос ускорился"
			},
			{
				"value": "b",
				"text": "Внедрить партиционирование по дате, оставить горячие данные в основной таблице, остальное архивировать и сжимать"
			},
			{
				"value": "c",
				"text": "Мигрировать на Hadoop — он точно справится с такими объёмами"
			},
			{
				"value": "d",
				"text": "Перейти на колоночное хранилище (например, ClickHouse), использовать агрегаты и TTL"
			},
			{
				"value": "e",
				"text": "Настроить лог-агент, чтобы не писать в БД напрямую, а использовать буферизацию через Redis"
			},
			{
				"value": "f",
				"text": "Оптимизировать движок хранения, перейти на SSD и пересчитать статистику планировщика запросов"
			},
			{
				"value": "g",
				"text": "Не знаю, никогда не работал с такими объемами логов"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 1,
			"d": 4,
			"e": 2,
			"f": 3,
			"g": 0
		}
	},
	{
		"id": "db2",
		"category": "database",
		"type": "practical",
		"question": "EXPLAIN показывает full table scan при запросе:\n\n```sql\nSELECT * FROM users WHERE status = 'active' AND created_at > '2024-01-01';\n```\n\nКакой индекс следует создать для ускорения этого запроса?",
		"options": [
			{
				"value": "a",
				"text": "Создам покрывающий фильтрованный индекс: WHERE status = 'active' INCLUDE (created_at, id)"
			},
			{
				"value": "b",
				"text": "Сделаю обычный индекс на created_at — фильтрация по дате всегда ускоряет"
			},
			{
				"value": "c",
				"text": "Составной индекс (status, created_at) — сначала по более селективному полю, потом по дате"
			},
			{
				"value": "d",
				"text": "Хеш-индекс на status и B-tree на created_at, добавлю индекс-хинт, чтобы движок сам выбрал"
			},
			{
				"value": "e",
				"text": "Добавлю индекс на поле status — ведь именно по нему чаще фильтруют"
			},
			{
				"value": "f",
				"text": "Не знаю, EXPLAIN никогда не использовал"
			}
		],
		"weights": {
			"a": 4,
			"b": 2,
			"c": 5,
			"d": 1,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "db3",
		"category": "database",
		"type": "case",
		"question": "Вы проектируете хранение иерархии категорий товаров (например, «Электроника > Компьютеры > Ноутбуки») в PostgreSQL. Данные будут часто читаться (поддеревья, родительские категории), изредка меняться. Какую модель хранения выберете?",
		"options": [
			{
				"value": "a",
				"text": "Список смежности (adjacency list) + рекурсивные CTE-запросы + кеширование путей для поддеревьев"
			},
			{
				"value": "b",
				"text": "Материализованный путь (materialized path) через PostgreSQL расширение ltree + индекс GiST + триггеры при изменении"
			},
			{
				"value": "c",
				"text": "Модель вложенных множеств (nested sets) с поддержанием левой и правой границы + обновлением счетчиков при вставке"
			},
			{
				"value": "d",
				"text": "Closure table — отдельная таблица путей со всеми предками и потомками + составной индекс (ancestor_id, descendant_id)"
			},
			{
				"value": "e",
				"text": "JSONB массив с перечислением всех предков, парсится при каждом запросе"
			},
			{
				"value": "f",
				"text": "Не знаю, хранил бы просто flat с parent_id и разберемся потом"
			}
		],
		"weights": {
			"a": 4,
			"b": 5,
			"c": 2,
			"d": 4,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "db4",
		"category": "database",
		"type": "practical",
		"question": "Джуниор написал: SELECT * FROM users WHERE age > 18 AND status = 'active' AND city = 'Moscow'. Запрос стал тормозить на большой выборке. Какой индекс поможет ускорить выполнение?",
		"options": [
			{
				"value": "a",
				"text": "CREATE INDEX idx_selective ON users(city, status, age) — порядок по селективности условий"
			},
			{
				"value": "b",
				"text": "CREATE INDEX idx_age ON users(age) WHERE status = 'active' — частичный индекс на активных"
			},
			{
				"value": "c",
				"text": "CREATE INDEX idx_all ON users(age, status, city) — составной по всем полям в любом порядке"
			},
			{
				"value": "d",
				"text": "Разделю таблицу на активных/неактивных пользователей — проще выбирать"
			},
			{
				"value": "e",
				"text": "Создам три отдельных индекса — пусть оптимизатор попробует Index Merge"
			},
			{
				"value": "f",
				"text": "Не знаю, у нас этим занимается DBA"
			},
			{
				"value": "g",
				"text": "Индексы зло, RAM подкину и будет летать"
			},
			{
				"value": "h",
				"text": "CREATE CLUSTERED INDEX — поможет, ведь данные отсортированы будут"
			}
		],
		"weights": {
			"a": 5,
			"b": 4,
			"c": 3,
			"d": 1,
			"e": 2,
			"f": 0,
			"g": 0,
			"h": 0
		}
	},
	{
		"id": "db5",
		"category": "database",
		"type": "practical",
		"question": "Как безопаснее всего хранить денежные значения (суммы) в PostgreSQL, чтобы избежать ошибок округления и обеспечить совместимость с разными валютами?",
		"options": [
			{
				"value": "a",
				"text": "BIGINT в минимальных единицах (например, копейках или центах) — высокая точность и отсутствие округлений"
			},
			{
				"value": "b",
				"text": "DECIMAL(19,4) — фиксированная точность, удобно для отчетов и большинства операций"
			},
			{
				"value": "c",
				"text": "Специализированный тип MONEY — простой, но ограничен локалью и форматом"
			},
			{
				"value": "d",
				"text": "FLOAT8 с округлением на уровне бизнес-логики — экономия места, но могут быть неточности"
			},
			{
				"value": "e",
				"text": "JSONB поле с amount и currency — удобно для микросервисов, но сложнее валидировать и индексировать"
			},
			{
				"value": "f",
				"text": "Две колонки: amount INTEGER и currency VARCHAR(3) — гибко и удобно для агрегации по валюте"
			},
			{
				"value": "g",
				"text": "Храним как строку (VARCHAR) и валидируем регуляркой — зато не потеряем точку"
			},
			{
				"value": "h",
				"text": "Главное — сделать CHECK на положительные значения, а тип не важен"
			}
		],
		"weights": {
			"a": 5,
			"b": 4,
			"c": 1,
			"d": 0,
			"e": 2,
			"f": 3,
			"g": 0,
			"h": 0
		}
	},
	{
		"id": "db6",
		"category": "database",
		"type": "case",
		"question": "Нужно реализовать полнотекстовый поиск по товарам. Проект небольшой, бюджета на инфраструктуру нет. Что выберете?",
		"options": [
			{
				"value": "a",
				"text": "PostgreSQL Full Text Search (FTS) с tsvector, индексацией по GIN и возможностью триграммного поиска — нативно и бесплатно"
			},
			{
				"value": "b",
				"text": "Кластер Elasticsearch с настройкой реплик, шардов и ранжированием по score — промышленный стандарт, но требует усилий"
			},
			{
				"value": "c",
				"text": "LIKE '%keyword%' + индекс на LOWER(name) — подойдет для админки, но не для реального поиска"
			},
			{
				"value": "d",
				"text": "SaaS-решение вроде Algolia или MeiliSearch — быстро стартовать, но придется платить и учитывать лимиты"
			},
			{
				"value": "e",
				"text": "Redis с модулем RediSearch — молниеносный поиск, если данные в памяти и не очень большие"
			},
			{
				"value": "f",
				"text": "Sphinx Search — старое доброе решение, если проект уже на нем и не хочется миграций"
			},
			{
				"value": "g",
				"text": "Регулярки в SQL: WHERE name ~* 'поиск' — универсально, но медленно и не масштабируется"
			},
			{
				"value": "h",
				"text": "Без понимания нагрузки, языков и требований к ранжированию сложно выбрать — нужен анализ"
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 1,
			"d": 4,
			"e": 3,
			"f": 2,
			"g": 0,
			"h": 3
		}
	},
	{
		"id": "db7",
		"category": "database",
		"type": "practical",
		"question": "В PostgreSQL таблица содержит колонку типа JSONB с вложенной структурой. Часто используются фильтры по полю data->'meta'->>'status'. Какой индекс использовать для ускорения запросов?",
		"options": [
			{
				"value": "a",
				"text": "GIN индекс на колонку data — позволит эффективно обрабатывать любые запросы к вложенным ключам"
			},
			{
				"value": "b",
				"text": "BTREE индекс на выражение (data->'meta'->>'status') — при высокой селективности фильтра даст наилучшую производительность"
			},
			{
				"value": "c",
				"text": "SP-GiST индекс — универсальное решение для всех типов JSONB данных"
			},
			{
				"value": "d",
				"text": "GIN индекс с оператором jsonb_path_ops — быстрый, но не поддерживает все типы запросов"
			},
			{
				"value": "e",
				"text": "Создать материализованное представление с распарсенным полем status и индексировать его"
			},
			{
				"value": "f",
				"text": "Не индексировать — JSONB слишком сложно предсказать, пусть планировщик сам разберётся"
			},
			{
				"value": "g",
				"text": "Я не знаю, как работает индексация JSONB, чаще использую VARCHAR"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 1,
			"d": 3,
			"e": 4,
			"f": 0,
			"g": 0
		}
	},
	{
		"id": "db8",
		"category": "database",
		"type": "case",
		"question": "В системе с высокой нагрузкой часто запрашивают данные пользователя вместе с его последними заказами. Что выберете?",
		"options": [
			{
				"value": "a",
				"text": "Нормализованные таблицы users и orders, связь по user_id, данные собираются джойном"
			},
			{
				"value": "b",
				"text": "Денормализованная таблица с повторяющимися данными пользователя в каждой записи заказа — быстрее, но дороже в хранении"
			},
			{
				"value": "c",
				"text": "Создание materialized view с объединенными данными и регулярным обновлением"
			},
			{
				"value": "d",
				"text": "Храним агрегаты последних заказов прямо в users в JSONB"
			},
			{
				"value": "e",
				"text": "Дублируем последние заказы в кэш Redis, обновляем по событию — основная БД остается нормализованной"
			},
			{
				"value": "f",
				"text": "Храним всё в одной таблице user_with_orders, чтобы не тратить ресурсы на JOIN"
			},
			{
				"value": "g",
				"text": "Не знаю, обычно архитекторы сами решают, как там с денормализацией быть"
			}
		],
		"weights": {
			"a": 3,
			"b": 2,
			"c": 4,
			"d": 3,
			"e": 5,
			"f": 1,
			"g": 0
		}
	},
	{
		"id": "db9",
		"category": "database",
		"type": "case",
		"question": "У вас два процесса одновременно обновляют остатки товаров в таблице stock. Иногда итоговая сумма получается неверной. Что делать?",
		"options": [
			{
				"value": "a",
				"text": "Обернуть операции в транзакцию с уровнем изоляции SERIALIZABLE"
			},
			{
				"value": "b",
				"text": "Добавить SELECT FOR UPDATE, чтобы блокировать строки при чтении"
			},
			{
				"value": "c",
				"text": "Использовать уровень изоляции READ UNCOMMITTED для ускорения работы"
			},
			{
				"value": "d",
				"text": "Переписать код без транзакций — просто обновлять остаток напрямую"
			},
			{
				"value": "e",
				"text": "Хранить stock в Redis и обновлять с помощью Lua-скриптов"
			},
			{
				"value": "f",
				"text": "Не знаю, надо будет спросить у DBA"
			}
		],
		"weights": { "a": 4, "b": 5, "c": 0, "d": 0, "e": 2, "f": 0 }
	},
	{
		"id": "db10",
		"category": "database",
		"type": "case",
		"question": "В отчёте внезапно появились лишние строки, которых не было при первом выполнении запроса. Один и тот же запрос во второй раз дал другой результат. Что это может быть?",
		"options": [
			{
				"value": "a",
				"text": "Фантомные чтения — при уровне READ COMMITTED возможны новые строки, вставленные другими транзакциями"
			},
			{
				"value": "b",
				"text": "Проблема с блокировками — другой запрос держит EXCLUSIVE LOCK на таблице"
			},
			{
				"value": "c",
				"text": "Ошибка из-за VACUUM — он удаляет старые строки и добавляет новые"
			},
			{
				"value": "d",
				"text": "Это признак грязного чтения — использован READ UNCOMMITTED"
			},
			{
				"value": "e",
				"text": "Это нормальное поведение PostgreSQL, он не гарантирует повторяемость выборок"
			},
			{
				"value": "f",
				"text": "Я пока не изучал уровни изоляции, не знаю"
			}
		],
		"weights": { "a": 5, "b": 2, "c": 0, "d": 3, "e": 1, "f": 0 }
	},
	{
		"id": "db11",
		"category": "database",
		"type": "practical",
		"question": "Какой уровень изоляции транзакций в PostgreSQL используется по умолчанию?",
		"options": [
			{
				"value": "a",
				"text": "READ UNCOMMITTED — можно читать даже незакоммиченные данные"
			},
			{
				"value": "b",
				"text": "READ COMMITTED — данные читаются только после коммита"
			},
			{
				"value": "c",
				"text": "REPEATABLE READ — все выборки в рамках транзакции дают одинаковый результат"
			},
			{
				"value": "d",
				"text": "SERIALIZABLE — самый строгий, как будто транзакции выполнялись по очереди"
			},
			{
				"value": "e",
				"text": "Не знаю, я пока не смотрел в сторону транзакций"
			}
		],
		"weights": { "a": 0, "b": 2, "c": 1, "d": 0, "e": 0 }
	},
	{
		"id": "db12",
		"category": "database",
		"type": "practical",
		"question": "Есть таблицы `users` и `orders`. Нужно получить всех пользователей, у которых есть хотя бы один заказ. Какой JOIN выбрать?",
		"options": [
			{
				"value": "a",
				"text": "LEFT JOIN + фильтр по orders.id IS NOT NULL"
			},
			{
				"value": "b",
				"text": "INNER JOIN users ON orders.user_id = users.id"
			},
			{
				"value": "c",
				"text": "RIGHT JOIN с orders и фильтрацией по users.id IS NOT NULL"
			},
			{
				"value": "d",
				"text": "FULL JOIN и выбрать только те, у кого user_id и order_id не пустые"
			},
			{
				"value": "e",
				"text": "CROSS JOIN с последующим WHERE orders.user_id = users.id"
			},
			{
				"value": "f",
				"text": "Не знаю, я просто использую SELECT * FROM users"
			}
		],
		"weights": {
			"a": 5,
			"b": 4,
			"c": 1,
			"d": 0,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "db13",
		"category": "database",
		"type": "case",
		"question": "Запрос с LEFT JOIN сильно тормозит. Таблицы: `customers` (10k) и `events` (100M). Нужно выбрать всех клиентов с их последним событием. Какой подход наиболее эффективен?",
		"options": [
			{
				"value": "a",
				"text": "Использовать подзапрос с LATERAL JOIN и ORDER BY event_time DESC LIMIT 1"
			},
			{
				"value": "b",
				"text": "Выполнить LEFT JOIN и затем группировку с MAX(event_time)"
			},
			{
				"value": "c",
				"text": "Создать материализованное представление с последними событиями для клиентов"
			},
			{
				"value": "d",
				"text": "Сделать FULL JOIN и фильтровать только последние события"
			},
			{
				"value": "e",
				"text": "Сортировать события и использовать DISTINCT ON (customer_id)"
			},
			{
				"value": "f",
				"text": "Отказаться от JOIN и делать два запроса в приложении"
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 4,
			"d": 0,
			"e": 5,
			"f": 2
		}
	},
	{
		"id": "db14",
		"category": "database",
		"type": "practical",
		"question": "Что из этого лучше всего подходит для выбора первичного ключа в таблице `users`?",
		"options": [
			{
				"value": "a",
				"text": "Поле `email`, потому что оно уникальное у всех пользователей"
			},
			{
				"value": "b",
				"text": "Автоинкрементное поле `id` типа BIGINT"
			},
			{
				"value": "c",
				"text": "Поле `phone_number`, потому что по нему удобно искать"
			},
			{
				"value": "d",
				"text": "Составной ключ из `first_name` и `last_name`"
			},
			{
				"value": "e",
				"text": "UUID, чтобы быть независимым от порядка вставки"
			},
			{
				"value": "f",
				"text": "Не знаю, я просто делаю таблицу без ключей"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 2,
			"d": 0,
			"e": 3,
			"f": 0
		}
	},
	{
		"id": "db15",
		"category": "database",
		"type": "case",
		"question": "В проекте обсуждается — использовать естественные ключи (например, VIN автомобиля) или суррогатные (например, автоинкрементное id). Какой подход выбрать?",
		"options": [
			{
				"value": "a",
				"text": "Суррогатный ключ — стабильный, неизменяемый, не зависит от бизнес-логики"
			},
			{
				"value": "b",
				"text": "Естественный ключ — позволяет избежать дубликатов и улучшает читаемость"
			},
			{
				"value": "c",
				"text": "Составной естественный ключ — всегда лучше, потому что он уникален в реальном мире"
			},
			{
				"value": "d",
				"text": "UUID — лучший выбор: уникален и не требует отдельной таблицы генерации"
			},
			{
				"value": "e",
				"text": "Использую естественные ключи, но добавляю суррогатный для внутренних связей"
			},
			{
				"value": "f",
				"text": "Выбираю подход в зависимости от стабильности бизнес-ключа и требований к миграциям"
			}
		],
		"weights": {
			"a": 5,
			"b": 3,
			"c": 1,
			"d": 3,
			"e": 4,
			"f": 5
		}
	},
	{
		"id": "db16",
		"category": "database",
		"type": "practical",
		"question": "Что произойдёт, если в таблице `orders` есть внешний ключ на `users.id`, и вы попытаетесь вставить заказ с `user_id = 9999`, которого нет в `users`?",
		"options": [
			{
				"value": "a",
				"text": "Будет ошибка вставки, так как внешний ключ не найдёт соответствия"
			},
			{
				"value": "b",
				"text": "Запрос выполнится, но `user_id` будет автоматически установлен в NULL"
			},
			{
				"value": "c",
				"text": "Запись вставится, но позже система удалит её по расписанию"
			},
			{
				"value": "d",
				"text": "Такого не произойдёт, если в таблице `orders` стоит ON DELETE CASCADE"
			},
			{
				"value": "e",
				"text": "Не знаю, мы не используем Foreign Keys, только soft-ссылки"
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 0,
			"d": 2,
			"e": 1
		}
	},
	{
		"id": "db17",
		"category": "database",
		"type": "case",
		"question": "В highload-системе решили убрать внешний ключ между `events` и `users`. Зачем так делают?",
		"options": [
			{
				"value": "a",
				"text": "Внешние ключи увеличивают нагрузку при вставке, особенно в системах с миллионами операций"
			},
			{
				"value": "b",
				"text": "Сложнее выполнять миграции или партиционирование таблиц с внешними зависимостями"
			},
			{
				"value": "c",
				"text": "Вместо FK используют soft reference — просто хранят `user_id` и проверяют валидность на уровне приложения"
			},
			{
				"value": "d",
				"text": "Потому что внешние ключи конфликтуют с шардингом и горизонтальным масштабированием"
			},
			{
				"value": "e",
				"text": "Они используют материализованные представления, которые сами обновляют связи"
			},
			{
				"value": "f",
				"text": "Это антипаттерн, FK надо использовать всегда"
			}
		],
		"weights": {
			"a": 5,
			"b": 4,
			"c": 4,
			"d": 3,
			"e": 2,
			"f": 0
		}
	},
	{
		"id": "db18",
		"category": "database",
		"type": "practical",
		"question": "Вы создали индекс на колонку, но EXPLAIN показывает full table scan. Что может быть причиной?",
		"options": [
			{
				"value": "a",
				"text": "Не знаю, кажется, нужно пересоздать таблицу"
			},
			{
				"value": "b",
				"text": "Оптимизатор БД может проигнорировать индекс, если считает, что полное сканирование быстрее"
			},
			{
				"value": "c",
				"text": "Индексы работают только при сортировке, а не при фильтрации"
			},
			{
				"value": "d",
				"text": "EXPLAIN иногда показывает старый план, нужно сделать REINDEX"
			},
			{
				"value": "e",
				"text": "Индекс заработает только после ANALYZE вручную"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 0,
			"d": 1,
			"e": 2
		}
	},
	{
		"id": "db19",
		"category": "database",
		"type": "case",
		"question": "Вы создали покрывающий индекс (covering index), но PostgreSQL не использует index only scan. Почему?",
		"options": [
			{
				"value": "a",
				"text": "Index only scan работает только на таблицах с первичным ключом"
			},
			{
				"value": "b",
				"text": "PostgreSQL может не использовать index only scan, если видимость строк в таблице не подтверждена VACUUM"
			},
			{
				"value": "c",
				"text": "Index only scan не работает, если в таблице есть nullable поля"
			},
			{
				"value": "d",
				"text": "Нужен дополнительный ANALYZE INDEX, иначе планировщик не поймёт, что индекс покрывает всё"
			},
			{
				"value": "e",
				"text": "Не знаю, EXPLAIN иногда врёт"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 2,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "db20",
		"category": "database",
		"type": "case",
		"question": "На таблице более 10 индексов. Какие потенциальные проблемы это может вызывать?",
		"options": [
			{
				"value": "a",
				"text": "Индексы конфликтуют между собой, что может вызвать deadlock"
			},
			{
				"value": "b",
				"text": "INSERT и UPDATE будут медленнее, так как каждый индекс нужно пересчитывать"
			},
			{
				"value": "c",
				"text": "PostgreSQL может случайно использовать неправильный индекс, если их много"
			},
			{
				"value": "d",
				"text": "Ничего страшного — оптимизатор всегда выберет лучший индекс, независимо от их количества"
			},
			{
				"value": "e",
				"text": "Индексы могут мешать autovacuum завершать цикл очистки"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 3,
			"d": 0,
			"e": 2
		}
	},
	{
		"id": "db21",
		"category": "database",
		"type": "case",
		"question": "У вас таблица с транзакциями за 5 лет. 500 млн записей. Нужно ускорить выборку за последний месяц. Что выбрать?",
		"options": [
			{
				"value": "a",
				"text": "Партиционирование по user_id — больше пользователей, больше шардинга"
			},
			{
				"value": "b",
				"text": "Партиционирование по дате (MONTH или RANGE по дате), локальный индекс только на последний partition"
			},
			{
				"value": "c",
				"text": "Партиционирование по сумме транзакции (amount), чтобы отделить крупные платежи"
			},
			{
				"value": "d",
				"text": "Хранить только последний месяц в оперативной БД, остальное выгрузить в архив"
			},
			{
				"value": "e",
				"text": "Создать один индекс на всю таблицу — индекс всегда ускоряет"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 1,
			"d": 4,
			"e": 0
		}
	},
	{
		"id": "db22",
		"category": "database",
		"type": "case",
		"question": "Система e-commerce выросла, таблица заказов перевалила за 2 миллиарда строк. Запросы начинают тормозить, появляются проблемы с масштабированием. Как поступите?",
		"options": [
			{
				"value": "a",
				"text": "Введу шардинг по user_id через middleware-слой с балансировкой и failover — простая маршрутизация и стабильный рост"
			},
			{
				"value": "b",
				"text": "Добавлю репликацию для чтения и индекс по всем часто используемым полям — не хочу усложнять архитектуру раньше времени"
			},
			{
				"value": "c",
				"text": "Поделю данные по году заказа (shard by time) — легко архивировать и ускорять недавние выборки"
			},
			{
				"value": "d",
				"text": "Мигрирую в монолитный ClickHouse — он лучше справляется с такими объёмами и позволяет не думать про шардинг"
			},
			{
				"value": "e",
				"text": "Перенесу заказы в отдельную микросервисную базу с шардингом по типу заказа (розница, опт, b2b)"
			},
			{
				"value": "f",
				"text": "Переведу данные в Redis — он быстрый, всё будет летать"
			}
		],
		"weights": {
			"a": 5,
			"b": 3,
			"c": 4,
			"d": 2,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "db23",
		"category": "database",
		"type": "case",
		"question": "Вы проектируете систему для интернет-магазина. Как правильно разделить роли OLTP и OLAP?",
		"options": [
			{
				"value": "a",
				"text": "Храню всё в одной базе и пишу аналитические отчёты через SELECT с джойнами — проще поддерживать"
			},
			{
				"value": "b",
				"text": "Использую PostgreSQL как универсальное решение — он и транзакции умеет, и CTE-шки красивые"
			},
			{
				"value": "c",
				"text": "Разделяю: транзакции идут в PostgreSQL, а данные регулярно выгружаются в ClickHouse для аналитики"
			},
			{
				"value": "d",
				"text": "Оставляю всё в OLTP и делаю копии таблиц с агрегатами — меньше технологий, меньше проблем"
			},
			{
				"value": "e",
				"text": "Делаю всё в Redis — это самый быстрый движок, значит справится с любыми задачами"
			}
		],
		"weights": {
			"a": 1,
			"b": 2,
			"c": 5,
			"d": 3,
			"e": 0
		}
	},
	{
		"id": "db24",
		"category": "database",
		"type": "case",
		"question": "У вас есть сервис анкетирования, где структура анкеты динамически меняется под клиента. Какой подход к хранению выбрать?",
		"options": [
			{
				"value": "a",
				"text": "Реляционная БД: таблица questions, таблица answers, связываем по foreign key"
			},
			{
				"value": "b",
				"text": "NoSQL с хранением ответов как JSON-документов — проще масштабировать и изменять структуру"
			},
			{
				"value": "c",
				"text": "CSV-файлы — просто и дешево, можно шарить через S3"
			},
			{
				"value": "d",
				"text": "Graph DB — ведь между вопросами бывают зависимости"
			},
			{
				"value": "e",
				"text": "SQLite на клиенте, потому что хочется offline-first"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 0,
			"d": 3,
			"e": 1
		}
	},
	{
		"id": "db25",
		"category": "database",
		"type": "practical",
		"question": "Когда стоит предпочесть NoSQL-решение вместо классической реляционной СУБД?",
		"options": [
			{
				"value": "a",
				"text": "Когда данные структурированы строго по 3NF и требуется сложная фильтрация через JOIN-ы"
			},
			{
				"value": "b",
				"text": "Когда система должна поддерживать ACID-гарантии и транзакции между таблицами"
			},
			{
				"value": "c",
				"text": "Когда требуется масштабируемость, поддержка ACIDless моделей и динамическая схема хранения"
			},
			{
				"value": "d",
				"text": "Когда необходимо реализовать event sourcing с сохранением всего состояния в базе"
			},
			{
				"value": "e",
				"text": "Когда основной приоритет — возможность оптимизировать SELECT-запросы с помощью materialized views"
			},
			{
				"value": "f",
				"text": "Затрудняюсь ответить, с NoSQL пока не работал"
			}
		],
		"weights": {
			"a": 0,
			"b": 1,
			"c": 5,
			"d": 3,
			"e": 1,
			"f": 2
		}
	},
	{
		"id": "db26",
		"category": "database",
		"type": "practical",
		"question": "Какой тип данных в PostgreSQL лучше всего подходит для хранения даты без времени?",
		"options": [
			{ "value": "a", "text": "DATE — предназначен для хранения только даты (год, месяц, день)" },
			{ "value": "b", "text": "TIMESTAMP — просто игнорируйте время, оно всё равно не мешает" },
			{ "value": "c", "text": "TEXT — можно хранить дату в формате 'YYYY-MM-DD'" },
			{ "value": "d", "text": "INTERVAL — можно задать дату через интервал от начала эпохи" },
			{ "value": "e", "text": "Не знаю, зависит от часового пояса" }
		],
		"weights": { "a": 5, "b": 1, "c": 2, "d": 0, "e": 1 }
	},
	{
		"id": "db27",
		"category": "database",
		"type": "case",
		"question": "В PostgreSQL нужно хранить уникальные идентификаторы в формате UUID. Какой тип выбрать?",
		"options": [
			{ "value": "a", "text": "UUID — встроенный тип PostgreSQL, оптимизированный под такие задачи" },
			{ "value": "b", "text": "TEXT — UUID это просто строка, никакой разницы нет" },
			{ "value": "c", "text": "BYTEA — можно хранить UUID как бинарный массив, это быстрее" },
			{ "value": "d", "text": "BIGINT — можно хешировать UUID в 64-битное число" },
			{ "value": "e", "text": "SERIAL — лучшее решение, UUID — это просто маркетинговый ход" }
		],
		"weights": { "a": 5, "b": 2, "c": 3, "d": 1, "e": 0 }
	},
	{
		"id": "db28",
		"category": "database",
		"type": "case",
		"question": "Нужно выбрать тип данных для хранения больших денежных сумм (до 10^12) с точностью до 6 знаков после запятой. Что учесть?",
		"options": [
			{
				"value": "a",
				"text": "NUMERIC(18,6) — точность фиксируется, но может влиять на производительность при агрегациях"
			},
			{
				"value": "b",
				"text": "DECIMAL — это синоним NUMERIC, но с более красивым названием"
			},
			{
				"value": "c",
				"text": "FLOAT8 — экономит место, а потери точности не критичны при больших суммах"
			},
			{
				"value": "d",
				"text": "BIGINT — можно хранить в минимальных единицах (например, миллионные доли), если известна масштабная константа"
			},
			{
				"value": "e",
				"text": "JSONB — гибко, можно хранить сумму и валюту в одном поле"
			},
			{
				"value": "f",
				"text": "MONEY — пригодится, если использовать PostgreSQL 9.2, там он ещё не deprecated"
			}
		],
		"weights": { "a": 5, "b": 3, "c": 1, "d": 4, "e": 2, "f": 0 }
	},
	{
		"id": "db29",
		"category": "database",
		"type": "case",
		"question": "Вы проектируете таблицу с колонкой `name`, куда будут попадать имена пользователей (до 100 символов). Какой тип данных выбрать и почему?",
		"options": [
			{
				"value": "a",
				"text": "VARCHAR(100) — позволяет задать ограничение длины, полезно для валидации и понимания бизнес-ограничений"
			},
			{
				"value": "b",
				"text": "TEXT — в PostgreSQL по сути то же, что и VARCHAR без ограничения, но без явного бизнес-лимита"
			},
			{
				"value": "c",
				"text": "CHAR(100) — будет хранить имена фиксированной длины, что ускоряет сравнение строк"
			},
			{
				"value": "d",
				"text": "VARCHAR — без указания длины, более гибко, а лимиты можно проверять логикой приложения"
			},
			{
				"value": "e",
				"text": "UUID — уникальные строки должны быть UUID, иначе искать неудобно"
			},
			{
				"value": "f",
				"text": "JSONB — имя пользователя можно хранить как часть структуры вместе с email и id"
			}
		],
		"weights": { "a": 5, "b": 3, "c": 1, "d": 4, "e": 0, "f": 1 }
	},
	{
		"id": "msg1",
		"category": "messaging",
		"type": "practical",
		"question": "Что делает брокер сообщений в распределённой системе?",
		"options": [
			{
				"value": "a",
				"text": "Принимает, хранит и пересылает сообщения между сервисами по заданным правилам"
			},
			{
				"value": "b",
				"text": "Распределяет логику обработки сообщений на микросервисы"
			},
			{
				"value": "c",
				"text": "Следит за нагрузкой и запускает новые копии сервисов при превышении лимитов"
			},
			{
				"value": "d",
				"text": "Шифрует сообщения и хранит ключи"
			},
			{
				"value": "e",
				"text": "Не знаю"
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 0,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "msg2",
		"category": "messaging",
		"type": "case",
		"question": "У вас Kafka-топик с 10 партициями. Как распределятся сообщения?",
		"options": [
			{
				"value": "a",
				"text": "По очереди в каждую партицию (round-robin), если ключ не задан"
			},
			{
				"value": "b",
				"text": "Только в первую партицию — остальные зарезервированы"
			},
			{
				"value": "c",
				"text": "Kafka сам случайно выбирает партиции, игнорируя ключ"
			},
			{
				"value": "d",
				"text": "Каждое сообщение записывается во все партиции одновременно"
			},
			{
				"value": "e",
				"text": "Я не знаю, что такое партиция"
			}
		],
		"weights": {
			"a": 5,
			"b": 0,
			"c": 1,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "msg3",
		"category": "messaging",
		"type": "practical",
		"question": "Что происходит в Kafka, если у топика всего одна партиция, а потребителей — двое в одной группе?",
		"options": [
			{
				"value": "a",
				"text": "Сообщения будут распределяться между двумя потребителями поровну"
			},
			{
				"value": "b",
				"text": "Только один потребитель получит данные — партиции нельзя шарить между несколькими потребителями в группе"
			},
			{
				"value": "c",
				"text": "Оба потребителя получат все сообщения, но с задержкой"
			},
			{
				"value": "d",
				"text": "Каждый потребитель будет получать только чётные или нечётные сообщения"
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 1,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "msg4",
		"category": "messaging",
		"type": "practical",
		"question": "Как Kafka распределяет сообщения между потребителями внутри одной consumer group?",
		"options": [
			{
				"value": "a",
				"text": "Каждому потребителю доставляются все сообщения"
			},
			{
				"value": "b",
				"text": "Каждая партиция закрепляется за одним потребителем — сообщения не дублируются"
			},
			{
				"value": "c",
				"text": "Все потребители получают копии, но сами определяют, кто обрабатывает"
			},
			{
				"value": "d",
				"text": "Только первый подключившийся потребитель получает сообщения"
			},
			{
				"value": "e",
				"text": "Я не уверен в разнице между группой и просто подпиской"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 1,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "msg5",
		"category": "messaging",
		"type": "case",
		"question": "Потребитель упал и перезапустился. Как обеспечить, чтобы он продолжил обработку с нужного места?",
		"options": [
			{
				"value": "a",
				"text": "Kafka сам отслеживает offset по ID сообщения и продолжит от него"
			},
			{
				"value": "b",
				"text": "Потребитель должен сохранять offset вручную или использовать автокоммит"
			},
			{
				"value": "c",
				"text": "Offset сбрасывается при перезапуске, так как он хранится в памяти"
			},
			{
				"value": "d",
				"text": "Надо использовать второй топик для хранения всех offset'ов"
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить — возможно, зависит от брокера"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 1,
			"d": 1,
			"e": 1
		}
	},
	{
		"id": "msg6",
		"category": "messaging",
		"type": "case",
		"question": "Что делать, если обработка сообщения из Kafka завершилась с ошибкой?",
		"options": [
			{
				"value": "a",
				"text": "Сразу коммитим offset и логируем ошибку"
			},
			{
				"value": "b",
				"text": "Используем retry-механику с экспоненциальной задержкой и DLT (Dead Letter Topic) при превышении лимита"
			},
			{
				"value": "c",
				"text": "Пишем это сообщение в PostgreSQL, потом обрабатываем отдельно"
			},
			{
				"value": "d",
				"text": "Kafka сам автоматически повторяет сообщение, пока оно не будет успешно обработано"
			},
			{
				"value": "e",
				"text": "Не знаю, как Kafka обрабатывает ошибки"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 2,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "msg7",
		"category": "messaging",
		"type": "case",
		"question": "Проектируете систему уведомлений для отправки 1 млн push-уведомлений. Какая архитектура подойдет лучше всего?",
		"options": [
			{
				"value": "a",
				"text": "Использование Event Grid с serverless-триггерами и временными лямбда-функциями на каждый push"
			},
			{
				"value": "b",
				"text": "Распределённый брокер (например, Kafka) с топиками по регионам, группами потребителей, dead-letter очередями и backoff retry pool’ами"
			},
			{
				"value": "c",
				"text": "SAGA orchestration на основе BPMN для отслеживания каждого push-уведомления и восстановления после неудач"
			},
			{
				"value": "d",
				"text": "Пакетная отправка через cron-задачи с периодическим подключением к внешнему push-сервису и ручным управлением партициями"
			},
			{
				"value": "e",
				"text": "Микросервисная архитектура со шлюзом API, rate limiting, distributed tracing и circuit breaker’ами"
			},
			{
				"value": "f",
				"text": "Я бы реализовал это через email-шлюз с fallback’ом на SMS, чтобы не потерять сообщения"
			},
			{
				"value": "g",
				"text": "Затрудняюсь ответить, не проектировал массовую отправку push-сообщений"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 2,
			"d": 1,
			"e": 3,
			"f": 0,
			"g": 1
		}
	},
	{
		"id": "msg8",
		"category": "messaging",
		"type": "practical",
		"question": "В Kafka необходимо обеспечить обработку событий с семантикой exactly-once. Какое из решений наиболее целостно покрывает задачу?",
		"options": [
			{
				"value": "a",
				"text": "Использовать Kafka Streams с state store и включенной семантикой exactly-once v2"
			},
			{
				"value": "b",
				"text": "Настроить transactional producer с idempotent ключами, transactional consumer и внешний стор с дедупликацией по message-id"
			},
			{
				"value": "c",
				"text": "Включить read_committed, управлять offset вручную через стороннюю базу и использовать EOS контроллер"
			},
			{
				"value": "d",
				"text": "Настроить минимальное количество реплик в ISR ≥ 3 и подтверждать запись с acks=all"
			},
			{
				"value": "e",
				"text": "Просто читать и записывать с включенной idempotence = true — этого достаточно для EOS"
			},
			{
				"value": "f",
				"text": "Затрудняюсь ответить — не работал с транзакциями в Kafka"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 2,
			"d": 1,
			"e": 0,
			"f": 1
		}
	},
	{
		"id": "msg9",
		"category": "messaging",
		"type": "case",
		"question": "Сообщения в очереди накапливаются быстрее, чем успевают обрабатываться. Что вы предпримете?",
		"options": [
			{
				"value": "a",
				"text": "Добавлю больше брокеров в кластер и увеличу partition count — это автоматически ускорит обработку"
			},
			{
				"value": "b",
				"text": "Включу оконную агрегацию, чтобы уменьшить общее количество сообщений, и внедрю ретрай с экспоненциальной задержкой"
			},
			{
				"value": "c",
				"text": "Настрою механизм backpressure: производитель будет ограничивать скорость публикации по загруженности топика"
			},
			{
				"value": "d",
				"text": "Использую autoscaling потребителей по лагу, при необходимости введу batch processing и QoS-приоритизацию очередей"
			},
			{
				"value": "e",
				"text": "Проблема решится сама после снижения трафика, нужно просто увеличить TTL хранения сообщений"
			},
			{
				"value": "f",
				"text": "Затрудняюсь ответить, не сталкивался с продакшен-очередями"
			}
		],
		"weights": {
			"a": 2,
			"b": 1,
			"c": 3,
			"d": 5,
			"e": 0,
			"f": 1
		}
	},
	{
		"id": "msg10",
		"category": "messaging",
		"type": "case",
		"question": "Выбираете между Kafka и RabbitMQ для системы заказов. Что важнее всего учесть?",
		"options": [
			{
				"value": "a",
				"text": "Kafka для микросервисов, RabbitMQ для монолита — это стандарт индустрии"
			},
			{
				"value": "b",
				"text": "Нужны ли event sourcing, replay сообщений и строгий порядок — тогда Kafka"
			},
			{
				"value": "c",
				"text": "Важно понять паттерны: pub/sub, work queues, routing — от этого зависит выбор"
			},
			{
				"value": "d",
				"text": "Вообще можно обойтись cron-задачами и таблицей в БД"
			},
			{
				"value": "e",
				"text": "Kafka быстрее, поэтому всегда выбираю её для продакшена"
			},
			{
				"value": "f",
				"text": "RabbitMQ проще в эксплуатации и достаточен для большинства задач с заказами"
			},
			{
				"value": "g",
				"text": "Оба устарели, лучше использовать Redis Streams или AWS SQS"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 5,
			"d": 1,
			"e": 0,
			"f": 4,
			"g": 1
		}
	},
	{
		"id": "msg11",
		"category": "messaging",
		"type": "practical",
		"question": "Consumer в Kafka отстает от producer на миллион сообщений. Как сократить лаг и догнать продюсера?",
		"options": [
			{
				"value": "a",
				"text": "Временно увеличить `max.poll.records`, чтобы за одну итерацию читать больше сообщений, и добавить параллельную обработку для ускорения прогресса."
			},
			{
				"value": "b",
				"text": "Честно, не знаю — миллион сообщений звучит как системная проблема, а не просто временная перегрузка."
			},
			{
				"value": "c",
				"text": "Уменьшить `replication.factor` до 1, чтобы снизить накладные расходы на запись и репликацию, тем самым ускорив работу кластера."
			},
			{
				"value": "d",
				"text": "Пропустить накопившиеся сообщения, установив `seek()` к последнему offset, чтобы начать читать только новые события."
			},
			{
				"value": "e",
				"text": "Перейти на Kafka Streams — он сам масштабируется и обеспечивает более эффективную работу с задержками в stateful-процессинге."
			},
			{
				"value": "f",
				"text": "Включить `enable.auto.commit=true`, чтобы уменьшить задержки, связанные с ручным управлением смещениями."
			},
			{
				"value": "g",
				"text": "Запустить несколько consumer-групп — они параллельно прочитают данные из топика и быстрее дойдут до актуального состояния."
			},
			{
				"value": "h",
				"text": "Добавить больше consumer-инстансов в существующую группу и увеличить число партиций, чтобы нагрузка распределилась и чтение ускорилось."
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 0,
			"d": 2,
			"e": 3,
			"f": 0,
			"g": 0,
			"h": 3
		}
	},
	{
		"id": "msg12",
		"category": "messaging",
		"type": "case",
		"question": "Нужно гарантировать порядок обработки событий для каждого пользователя при высокой нагрузке. Как спроектировать архитектуру очередей?",
		"options": [
			{
				"value": "a",
				"text": "Использовать ключ маршрутизации (routing key) или message key по user_id для consistent hashing — это обеспечит попадание всех сообщений одного пользователя в одну логическую очередь или партицию."
			},
			{
				"value": "b",
				"text": "Создать отдельную очередь на каждого пользователя — решение радикальное, но гарантирует абсолютный порядок."
			},
			{
				"value": "c",
				"text": "Применить Redis Sorted Set с timestamp в качестве score — можно вручную контролировать порядок и переупорядочивать сообщения."
			},
			{
				"value": "d",
				"text": "Ставить timestamp в сообщение и сортировать их на стороне consumer — просто и эффективно, особенно если задержки допустимы."
			},
			{
				"value": "e",
				"text": "Kafka с партиционированием по user_id: все события одного пользователя попадут в одну партицию, где порядок гарантирован брокером."
			},
			{
				"value": "f",
				"text": "Ограничить throughput и обрабатывать события синхронно через REST API — никакой очереди, никакой параллельности, 100% порядок."
			},
			{
				"value": "g",
				"text": "Порядок не важен, если логика потребителя идемпотентна — лучше сосредоточиться на производительности, а не на очередности."
			},
			{
				"value": "h",
				"text": "Тут нет универсального решения — всё зависит от RPS, SLA и распределенности системы. Иногда микс нескольких подходов работает лучше."
			}
		],
		"weights": {
			"a": 4,
			"b": 2,
			"c": 3,
			"d": 1,
			"e": 5,
			"f": 0,
			"g": 0,
			"h": 2
		}
	},
	{
		"id": "msg13",
		"category": "messaging",
		"type": "case",
		"question": "Нужно гарантировать порядок обработки событий для каждого пользователя при высокой нагрузке. Как спроектировать архитектуру очередей?",
		"options": [
			{
				"value": "a",
				"text": "Использовать ключ маршрутизации (routing key) или message key по user_id для consistent hashing — это обеспечит попадание всех сообщений одного пользователя в одну логическую очередь или партицию."
			},
			{
				"value": "b",
				"text": "Создать отдельную очередь на каждого пользователя — решение радикальное, но гарантирует абсолютный порядок."
			},
			{
				"value": "c",
				"text": "Применить Redis Sorted Set с timestamp в качестве score — можно вручную контролировать порядок и переупорядочивать сообщения."
			},
			{
				"value": "d",
				"text": "Ставить timestamp в сообщение и сортировать их на стороне consumer — просто и эффективно, особенно если задержки допустимы."
			},
			{
				"value": "e",
				"text": "Kafka с партиционированием по user_id: все события одного пользователя попадут в одну партицию, где порядок гарантирован брокером."
			},
			{
				"value": "f",
				"text": "Ограничить throughput и обрабатывать события синхронно через REST API — никакой очереди, никакой параллельности, 100% порядок."
			},
			{
				"value": "g",
				"text": "Порядок не важен, если логика потребителя идемпотентна — лучше сосредоточиться на производительности, а не на очередности."
			},
			{
				"value": "h",
				"text": "Тут нет универсального решения — всё зависит от RPS, SLA и распределенности системы. Иногда микс нескольких подходов работает лучше."
			}
		],
		"weights": {
			"a": 4,
			"b": 2,
			"c": 3,
			"d": 1,
			"e": 5,
			"f": 0,
			"g": 0,
			"h": 2
		}
	},
	{
		"id": "msg14",
		"category": "messaging",
		"type": "case",
		"question": "Сервис получает дублирующиеся события из внешней системы (например, из Kafka или по webhook). Как обеспечить идемпотентную обработку?",
		"options": [
			{
				"value": "a",
				"text": "Хранить хеши всех сообщений (например, SHA-256 от payload) и проверять перед обработкой — простая реализация, но может приводить к коллизиям и требует контроля объема хранилища"
			},
			{
				"value": "b",
				"text": "Добавить уникальный idempotency key в каждое сообщение (например, UUID или order_id) и проверять по нему: если уже обрабатывали — пропускаем. Универсальный и надёжный способ, особенно при повторной доставке"
			},
			{
				"value": "c",
				"text": "Ограничить частоту входящих запросов с помощью rate limiter (например, по IP или ключу) — поможет от перегрузки, но не от логических дублей, особенно если источник ретраит с разным интервалом"
			},
			{
				"value": "d",
				"text": "Разделить консюмеров по группам, чтобы каждый обрабатывал свою часть сообщений — масштабирует систему, но не решает проблему дублей: один и тот же consumer всё равно может получить дубликат"
			},
			{
				"value": "e",
				"text": "Сделать сервис stateless и надеяться, что дубли не критичны — подходит только для безопасных идемпотентных операций (например, GET), но для изменений состояния (POST, PATCH) это риск"
			},
			{
				"value": "f",
				"text": "Отправлять ack с таймаутом и ретраить обработку — только увеличивает шанс дубликатов, если нет идемпотентности, может привести к двойному выполнению"
			},
			{
				"value": "g",
				"text": "Попросить внешний источник не присылать дубли — наивный подход, так как ретраи и дублирование могут быть частью архитектурной гарантии доставки"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 1,
			"d": 1,
			"e": 0,
			"f": 0,
			"g": 0
		}
	},
	{
		"id": "msg15",
		"category": "messaging",
		"type": "case",
		"question": "В распределенной системе запрос проходит через несколько микросервисов. Как обеспечить трассировку и связать все логи между собой?",
		"options": [
			{
				"value": "a",
				"text": "Внедрить единый correlation ID, прокидывать его через заголовки HTTP/gRPC и писать в логи каждого сервиса — это позволит отслеживать цепочку вызовов"
			},
			{
				"value": "b",
				"text": "Использовать UUID каждого запроса в теле сообщения и хранить его в базе — можно потом связать вручную при анализе логов"
			},
			{
				"value": "c",
				"text": "Включить DEBUG-логи во всех сервисах — трассировка обеспечена, просто собери все логи и найди нужные вручную"
			},
			{
				"value": "d",
				"text": "Настроить distributed tracing через OpenTelemetry или Jaeger с автоматическим сбором трассировки и передачей контекста"
			},
			{
				"value": "e",
				"text": "Добавить в payload сообщения поле `source_service` и искать вручную по порядку прохождения систем"
			},
			{
				"value": "f",
				"text": "Создать отдельный лог-сервис, куда отправляются все логи всех сервисов — там уже как-нибудь разберемся"
			},
			{
				"value": "g",
				"text": "Затрудняюсь ответить, обычно DevOps всё это уже настраивают"
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 0,
			"d": 4,
			"e": 1,
			"f": 1,
			"g": 0
		}
	},
	{
		"id": "msg16",
		"category": "messaging",
		"type": "case",
		"question": "Вы проектируете систему на базе событийной архитектуры. Какой подход лучше отражает принципы Event-Driven?",
		"options": [
			{
				"value": "a",
				"text": "Производители публикуют события в брокер, подписчики реагируют независимо. Нет жёсткой связанности, используется Pub/Sub."
			},
			{
				"value": "b",
				"text": "Один оркестратор вызывает каждый микросервис по порядку, передавая результат следующему — строгое управление потоком."
			},
			{
				"value": "c",
				"text": "Все компоненты общаются через общую базу данных — события записываются в таблицу логов."
			},
			{
				"value": "d",
				"text": "Каждый сервис напрямую вызывает REST API других — проще отлаживать последовательность вызовов."
			},
			{
				"value": "e",
				"text": "Публиковать события можно, но лучше использовать централизованную очередь команд и выполнять строго по порядку."
			},
			{
				"value": "f",
				"text": "Отправлять события по email — так точно увидят."
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 1,
			"d": 0,
			"e": 2,
			"f": 0
		}
	},
	{
		"id": "msg12",
		"category": "messaging",
		"type": "case",
		"question": "Вы проектируете микросервисную систему. Когда предпочтительнее использовать хореографию событий вместо оркестрации?",
		"options": [
			{
				"value": "a",
				"text": "Когда хочется избежать централизованного компонента, а логика построена на реакциях сервисов на события"
			},
			{
				"value": "b",
				"text": "Когда один управляющий сервис знает порядок действий и координирует исполнение шагов через API вызовы"
			},
			{
				"value": "c",
				"text": "Когда нужен строгий контроль над последовательностью шагов и rollback в случае сбоя"
			},
			{
				"value": "d",
				"text": "Когда используется очередь команд и обработка строго по FIFO — иначе возможны гонки"
			},
			{
				"value": "e",
				"text": "Когда все действия идут через BPMN-движок или Camunda, и логика централизована в диаграмме"
			},
			{
				"value": "f",
				"text": "Когда хочется упростить отладку, централизовать логи и контролировать транзакции"
			},
			{
				"value": "g",
				"text": "Не знаю, всегда использовал оркестрацию — она проще"
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 2,
			"d": 1,
			"e": 1,
			"f": 2,
			"g": 0
		}
	},
	{
		"id": "msg17",
		"category": "messaging",
		"type": "case",
		"question": "Вы проектируете взаимодействие между микросервисами. Почему не всегда стоит использовать асинхронное взаимодействие (через брокеры сообщений)?",
		"options": [
			{
				"value": "a",
				"text": "Асинхронность усложняет трассировку, требует correlation ID и не всегда подходит, когда важна последовательность и безопасность"
			},
			{
				"value": "b",
				"text": "REST API быстрее, чем асинхронные брокеры, и работает без задержек"
			},
			{
				"value": "c",
				"text": "Брокеры не гарантируют доставку, даже с репликацией — поэтому лучше использовать синхронное взаимодействие"
			},
			{
				"value": "d",
				"text": "Асинхронность всегда хуже, потому что нет контроля над ответом, и это устаревший паттерн"
			},
			{
				"value": "e",
				"text": "Kafka и RabbitMQ сложно масштабировать, и они не подходят для распределенных систем"
			},
			{
				"value": "f",
				"text": "Асинхронные системы требуют дополнительных компонентов: брокеров, очередей, политик безопасности — это повышает сложность поддержки"
			},
			{
				"value": "g",
				"text": "Не знаю. Все сейчас делают микросервисы и Kafka — наверное, это правильно"
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 2,
			"d": 0,
			"e": 1,
			"f": 4,
			"g": 0
		}
	},
	{
		"id": "sys1",
		"category": "system_design",
		"type": "case",
		"question": "Вы приступаете к системному дизайну нового крупного IT-продукта. Какой подход отражает суть системного дизайна?",
		"options": [
			{
				"value": "a",
				"text": "Построение архитектуры на основе выбранного языка и инфраструктуры, включая API-гейтвеи, базу и окружение"
			},
			{
				"value": "b",
				"text": "Разработка макетов пользовательского интерфейса и сценариев, чтобы определить взаимодействие пользователя с системой"
			},
			{
				"value": "c",
				"text": "Формирование структуры компонентов, взаимодействий между ними, ограничений системы, требований по отказоустойчивости и масштабированию"
			},
			{
				"value": "d",
				"text": "Составление технической документации, диаграмм компонентов и маршрутов данных, чтобы разработчикам было проще начать"
			},
			{
				"value": "e",
				"text": "Системный дизайн — это скорее абстрактная идея, чем чёткий процесс. Точного ответа тут нет"
			},
			{
				"value": "f",
				"text": "Основной упор — на выбор проверенных библиотек, фреймворков и CI/CD пайплайнов, чтобы ускорить реализацию"
			}
		],
		"weights": {
			"a": 2,
			"b": 1,
			"c": 5,
			"d": 3,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "sys2",
		"category": "system_design",
		"type": "case",
		"question": "На ранней стадии проектирования новой системы какие аспекты стоит обязательно проанализировать?",
		"options": [
			{
				"value": "a",
				"text": "Определить SLA для команд и метрики по velocity — чтобы заранее понимать эффективность команды разработки"
			},
			{
				"value": "b",
				"text": "Фиксировать цветовую палитру и систематизировать UI-паттерны — это улучшает восприятие продукта и снижает стоимость изменений"
			},
			{
				"value": "c",
				"text": "Согласовать бизнес-приоритеты, потенциальные интеграции, ограничения на масштабируемость и устойчивость к сбоям"
			},
			{
				"value": "d",
				"text": "Определить стиль API (REST, gRPC или GraphQL) — это базовая точка, от которой зависят архитектурные выборы"
			},
			{
				"value": "e",
				"text": "Утвердить структуру репозиториев и naming-конвенции — несогласованность здесь сильно тормозит рост проекта"
			},
			{
				"value": "f",
				"text": "Трудно сказать — многое зависит от команды, домена и стейкхолдеров"
			}
		],
		"weights": {
			"a": 1,
			"b": 0,
			"c": 5,
			"d": 2,
			"e": 1,
			"f": 1
		}
	},
	{
		"id": "sys3",
		"category": "system_design",
		"type": "case",
		"question": "Black Friday. Система не выдерживает резкий рост трафика. Какие действия помогут оперативно стабилизировать ситуацию?",
		"options": [
			{
				"value": "a",
				"text": "Включение режима техобслуживания с экраном ожидания и постепенным впуском пользователей — снижает пиковую нагрузку и предотвращает полный коллапс"
			},
			{
				"value": "b",
				"text": "Внедрение адаптивного ограничения запросов, отключение нефункциональных модулей через feature flags, агрессивное кеширование, экстренное масштабирование — комбинация быстрых технических мер"
			},
			{
				"value": "c",
				"text": "Срочное выделение дополнительных серверов через spot-инстансы и временное повышение квот сторонних API — быстрый, но рискованный путь"
			},
			{
				"value": "d",
				"text": "Форсированная оптимизация медленных SQL-запросов, кэширование всего подряд и принудительное упрощение UI — даёт выигрыш времени, но эффект может быть краткосрочным"
			},
			{
				"value": "e",
				"text": "Временный редирект части трафика на заглушку или статическую страницу — помогает выиграть время и удержать пользователей"
			},
			{
				"value": "f",
				"text": "Увеличение таймаутов на всех внешних зависимостях — позволит дождаться ответа, снизив число ошибок"
			},
			{
				"value": "g",
				"text": "Отключение логирования — уменьшит I/O, что может стабилизировать систему"
			},
			{
				"value": "h",
				"text": "Не знаю. Возможно, стоит просто перезапустить сервисы"
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 4,
			"d": 2,
			"e": 3,
			"f": 1,
			"g": 0,
			"h": 1
		}
	},
	{
		"id": "sys4",
		"category": "system_design",
		"type": "case",
		"question": "Вы проектируете распределённую систему. В условиях сетовой задержки и разделения, как работает CAP-теорема?",
		"options": [
			{
				"value": "a",
				"text": "Система может одновременно обеспечить согласованность, доступность и устойчивость к разделению сети, если настроить правильный баланс"
			},
			{
				"value": "b",
				"text": "В условиях сетового разделения приходится жертвовать либо согласованностью, либо доступностью — нельзя получить всё сразу"
			},
			{
				"value": "c",
				"text": "CAP — это подход к мониторингу: Consistency, Availability и Performance"
			},
			{
				"value": "d",
				"text": "Если в системе нет сетевых ошибок, CAP не применим"
			},
			{
				"value": "e",
				"text": "Согласованность в CAP означает, что все ноды возвращают одно и то же значение после выполнения любой операции"
			},
			{
				"value": "f",
				"text": "Затрудняюсь ответить. CAP всегда вызывала путаницу"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 0,
			"d": 1,
			"e": 3,
			"f": 1
		}
	},
	{
		"id": "sys5",
		"category": "system_design",
		"type": "case",
		"question": "Вы работаете с системой, где важна масштабируемость и высокая доступность. Что означает eventual consistency?",
		"options": [
			{
				"value": "a",
				"text": "Все записи сохраняются в очередь и гарантированно обрабатываются в том порядке, в котором они были созданы"
			},
			{
				"value": "b",
				"text": "Система может возвращать устаревшие данные, но гарантирует, что в конечном счёте все ноды синхронизируются"
			},
			{
				"value": "c",
				"text": "Это режим блокировок на чтение, пока не завершится запись, чтобы гарантировать консистентность"
			},
			{
				"value": "d",
				"text": "Eventual consistency означает, что данные никогда не дублируются, и система масштабируется без задержек"
			},
			{
				"value": "e",
				"text": "Подход, при котором клиент сам отвечает за согласование конфликта между версиями"
			},
			{
				"value": "f",
				"text": "Затрудняюсь ответить. Никогда не понимал, чем eventual от strong отличается"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 1,
			"d": 0,
			"e": 3,
			"f": 1
		}
	},
	{
		"id": "sys6",
		"category": "system_design",
		"type": "case",
		"question": "Вы работаете над системой, где термин 'Клиент' означает разные вещи в CRM, биллинге и доставке. Какое архитектурное решение наилучшим образом позволит избежать путаницы и конфликтов в понимании данных?",
		"options": [
			{
				"value": "a",
				"text": "Ввести единый универсальный справочник 'Клиентов', чтобы все модули работали с одной моделью"
			},
			{
				"value": "b",
				"text": "Использовать Bounded Context — каждый модуль определяет 'Клиента' по-своему, границы между моделями строго очерчены"
			},
			{
				"value": "c",
				"text": "Добавить дополнительную таблицу мета-информации и единый API-контракт с расширяемой схемой JSON"
			},
			{
				"value": "d",
				"text": "Разделить команды разработки по модулям и договориться, чтобы они не пересекались в использовании слова 'Клиент'"
			},
			{
				"value": "e",
				"text": "Заменить термин 'Клиент' на синонимы вроде 'Контрагент', 'Плательщик' и 'Получатель', чтобы избежать конфликта терминов"
			},
			{
				"value": "f",
				"text": "Не знаю. Вроде 'Клиент' должен быть один и понятный во всей компании"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 3,
			"d": 1,
			"e": 2,
			"f": 0
		}
	},
	{
		"id": "sys7",
		"category": "system_design",
		"type": "case",
		"question": "В компании начинают внедрять принципы Domain-Driven Design. Команда обсуждает, с чего начать. Какой подход наиболее соответствует духу DDD?",
		"options": [
			{
				"value": "a",
				"text": "Нарисовать техническую архитектуру всех будущих сервисов и утвердить ее с архитекторами до начала проектирования модели"
			},
			{
				"value": "b",
				"text": "Начать с выявления бизнес-домена, выделения поддоменов, поиска bounded context'ов и построения модели, исходя из языка предметной области"
			},
			{
				"value": "c",
				"text": "Разделить систему на модули по слоям (контроллеры, сервисы, репозитории) и постепенно обогащать бизнес-логику"
			},
			{
				"value": "d",
				"text": "Использовать микросервисную архитектуру, где каждый сервис мапится на отдельную бизнес-функцию"
			},
			{
				"value": "e",
				"text": "Сначала построить ER-диаграмму с нормализованной структурой данных и на ее основе определить бизнес-домены"
			},
			{
				"value": "f",
				"text": "Затрудняюсь ответить, похоже, тут важна глубина проработки, а не только архитектура"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 2,
			"d": 3,
			"e": 1,
			"f": 0
		}
	},
	{
		"id": "sys8",
		"category": "system_design",
		"type": "case",
		"question": "Вы запустили веб-сервис для генерации PDF по запросу пользователя. После запуска в продакшене стало поступать до 10 000 запросов в минуту, и система начала деградировать. Какие действия предпринять, чтобы обеспечить масштабируемость?",
		"options": [
			{
				"value": "a",
				"text": "Вынести тяжёлую генерацию PDF в отдельный воркер, обрабатывающий задачи из очереди, чтобы снизить нагрузку на веб-прослойку"
			},
			{
				"value": "b",
				"text": "Добавить больше памяти и процессоров на сервере, где крутится веб-сервер, чтобы он обрабатывал больше запросов одновременно"
			},
			{
				"value": "c",
				"text": "Разделить API на отдельные микросервисы и сразу внедрить event-driven архитектуру на Kafka"
			},
			{
				"value": "d",
				"text": "Кешировать готовые PDF на стороне клиента, чтобы уменьшить повторные запросы"
			},
			{
				"value": "e",
				"text": "Временно ограничить частоту генерации PDF через rate limiter и возвращать заглушку или 429 Too Many Requests при превышении лимита"
			},
			{
				"value": "f",
				"text": "Я не уверен, нужно сначала провести замеры (профилирование, метрики) и только потом принимать архитектурные решения"
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 2,
			"d": 1,
			"e": 3,
			"f": 4
		}
	},
	{
		"id": "sys10",
		"category": "system_design",
		"type": "case",
		"question": "Вы проектируете крупную систему, где важны скорость вывода на рынок и масштабируемость. Какой архитектурный подход уместен?",
		"options": [
			{
				"value": "a",
				"text": "Выделенные сервисные домены с возможностью независимой доставки, но с общей схемой БД для ускорения обмена данными на старте"
			},
			{
				"value": "b",
				"text": "Декомпозиция по принципу Self-contained Systems с полной автономией компонентов (UI, бизнес-логика, данные), каждый блок — как мини-продукт"
			},
			{
				"value": "c",
				"text": "Начать с модульного монолита с четкими границами, подготовленными к последующему выносу в сервисы, но с единым деплоем"
			},
			{
				"value": "d",
				"text": "Сразу строить полноценную микросервисную архитектуру, используя отдельные репозитории, CI/CD пайплайны и распределённую трассировку"
			},
			{
				"value": "e",
				"text": "Собрать MVP как набор REST-сервисов на одном сервере, а при росте нагрузки перейти на Kubernetes и нарезать по доменам"
			},
			{
				"value": "f",
				"text": "Я не уверен, что есть универсальный рецепт — архитектура должна выстраиваться от команды и зрелости процессов"
			}
		],
		"weights": {
			"a": 2,
			"b": 4,
			"c": 5,
			"d": 3,
			"e": 0,
			"f": 1
		}
	},
	{
		"id": "sys11",
		"category": "system_design",
		"type": "case",
		"question": "Система начала испытывать перегрузку на уровне базы данных из-за большого объема записей и высокой нагрузки на чтение и запись. Какие меры помогут масштабировать хранилище?",
		"options": [
			{
				"value": "a",
				"text": "Вертикальное масштабирование (мощнее сервер, больше памяти) + кеширование для снижения нагрузки на базу — дает быстрый эффект, но имеет ограниченный потолок"
			},
			{
				"value": "b",
				"text": "Шардирование по бизнес-ключу (например, по user_id) — позволяет горизонтально масштабировать запись, снизив нагрузку на отдельные узлы базы"
			},
			{
				"value": "c",
				"text": "Репликация базы: одна нода на запись, остальные на чтение — позволяет масштабировать чтение без риска конфликтов записи"
			},
			{
				"value": "d",
				"text": "CQRS: разделить модели и хранилища для чтения и записи — повышает масштабируемость и позволяет оптимизировать каждый путь отдельно"
			},
			{
				"value": "e",
				"text": "Переход на NoSQL: документные базы масштабируются горизонтально, но требует пересмотра модели данных и отказа от сложных связей"
			},
			{
				"value": "f",
				"text": "GraphQL быстрее, чем SQL, поэтому он может снизить нагрузку на базу — особенно, если использовать фрагменты и клиентский кеш"
			},
			{
				"value": "g",
				"text": "Затрудняюсь ответить, архитектурно не сталкивался с такими нагрузками"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 3,
			"d": 4,
			"e": 1,
			"f": 0,
			"g": 0
		}
	},
	{
		"id": "sys9",
		"category": "system_design",
		"type": "case",
		"question": "Вы проектируете систему логирования событий, которые приходят с тысяч устройств в режиме реального времени. Что важно учесть при выборе БД?",
		"options": [
			{
				"value": "a",
				"text": "Выбрать графовую БД — она идеально подходит для хранения связей между событиями и ускоряет аналитические запросы"
			},
			{
				"value": "b",
				"text": "Использовать TimescaleDB или ClickHouse — они ориентированы на временные ряды и поддержку аналитических запросов по времени. Хорошо масштабируются, особенно в режиме write-heavy"
			},
			{
				"value": "c",
				"text": "Выбрать документоориентированную NoSQL-базу, например MongoDB — масштабируется горизонтально, не требует строгой схемы, но может не справляться с write-интенсивной нагрузкой"
			},
			{
				"value": "d",
				"text": "Использовать Redis — быстрая in-memory база, отлично подходит для хранения логов, но данные не сохраняются долговременно и могут теряться при сбое"
			},
			{
				"value": "e",
				"text": "Не знаю. Нужно больше информации о требованиях к чтению, хранению и аналитике"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 2,
			"d": 1,
			"e": 1
		}
	},
	{
		"id": "sys10",
		"category": "system_design",
		"type": "case",
		"question": "Вы проектируете API-сервис, который обрабатывает запросы клиентов и должен масштабироваться под пиковую нагрузку. Какой подход к хранению состояния предпочтительнее?",
		"options": [
			{
				"value": "a",
				"text": "Сделать сервис stateful и использовать локальную память для хранения пользовательских сессий — это быстрее и проще для чтения состояния"
			},
			{
				"value": "b",
				"text": "Сделать сервис stateless, хранить сессии в Redis или другой внешней системе — это позволит легко масштабировать сервис, так как инстансы не зависят от состояния"
			},
			{
				"value": "c",
				"text": "Выбирать между stateful и stateless нужно только после анализа бизнес-логики — не имеет смысла закладываться на это заранее"
			},
			{
				"value": "d",
				"text": "Использовать куки в браузере для хранения всего состояния клиента, включая бизнес-логику и доступы — это полностью избавит сервис от работы с состоянием"
			},
			{
				"value": "e",
				"text": "Не знаю, зависит от того, что именно считается состоянием в этом контексте"
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 2,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "sys11",
		"category": "system_design",
		"type": "case",
		"question": "Сервис часто обращается к базе данных с одними и теми же запросами. Какой подход к кешированию будет наиболее устойчивым и масштабируемым?",
		"options": [
			{
				"value": "a",
				"text": "Использовать CDN, чтобы не было обращений к базе — все кешируется на уровне сети и браузера"
			},
			{
				"value": "b",
				"text": "Кешировать результаты в памяти каждого инстанса сервиса — это самый быстрый доступ, но есть риск расхождения данных между инстансами"
			},
			{
				"value": "c",
				"text": "Вынести кеш в Redis, использовать ключи с TTL и инвалидацию при обновлении данных — это централизованно, масштабируемо и контролируемо"
			},
			{
				"value": "d",
				"text": "Обновлять кеш по крону раз в 10 минут и полностью сбрасывать его при каждом изменении данных — это снизит сложность"
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить, не совсем понимаю, как кеш и база должны согласовываться"
			}
		],
		"weights": {
			"a": 1,
			"b": 2,
			"c": 5,
			"d": 1,
			"e": 1
		}
	},
	{
		"id": "sys12",
		"category": "system_design",
		"type": "case",
		"question": "У вас есть API, к которому одновременно обращаются тысячи клиентов. Как реализовать устойчивый и масштабируемый механизм ограничения запросов (rate limiting)?",
		"options": [
			{
				"value": "a",
				"text": "Добавить middleware, который проверяет лимит запросов внутри каждого инстанса — быстро, но не учитывает общую нагрузку между инстансами"
			},
			{
				"value": "b",
				"text": "Использовать Redis в качестве централизованного хранилища счётчиков, реализуя алгоритм Token Bucket или Sliding Window на уровне всей инфраструктуры"
			},
			{
				"value": "c",
				"text": "Внедрить distributed lock на базе Zookeeper для контроля количества запросов в реальном времени"
			},
			{
				"value": "d",
				"text": "Периодически выгружать access-логи и анализировать их вручную, чтобы настроить лимиты на уровне firewall"
			},
			{
				"value": "e",
				"text": "Я затрудняюсь ответить — rate limiter всегда вызывает много вопросов"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 1,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "sys13",
		"category": "system_design",
		"type": "case",
		"question": "У вас есть сервис A, который зависит от сервиса B. В последнее время B часто не отвечает или отвечает с большой задержкой. Как можно избежать лавинообразных таймаутов и деградации A?",
		"options": [
			{
				"value": "a",
				"text": "Внедрить Circuit Breaker между сервисами: при превышении порога ошибок разрывать цепь вызова и переходить на fallback-логику (например, кэш, заглушки или 503)"
			},
			{
				"value": "b",
				"text": "Настроить load balancer, чтобы перенаправлять трафик с A на другие healthy инстансы B"
			},
			{
				"value": "c",
				"text": "Просто увеличить таймауты в A, чтобы дать B больше времени на ответ — это решит проблему перегрузки"
			},
			{
				"value": "d",
				"text": "Добавить retry policy с экспоненциальной задержкой, чтобы A автоматически повторял запрос при ошибках B"
			},
			{
				"value": "e",
				"text": "Я затрудняюсь ответить, возможно, нужно сначала провести анализ метрик"
			}
		],
		"weights": {
			"a": 5,
			"b": 2,
			"c": 0,
			"d": 3,
			"e": 1
		}
	},
	{
		"id": "sys14",
		"category": "system_design",
		"type": "case",
		"question": "Сервис A вызывает сторонний API, который периодически даёт ошибки. Как грамотно реализовать политику повторов (Retry Policy)?",
		"options": [
			{
				"value": "a",
				"text": "Повторять запросы бесконечно с интервалом в 100 мс — в большинстве случаев это помогает"
			},
			{
				"value": "b",
				"text": "Использовать ограниченное число попыток с экспоненциальной задержкой и джиттером, чтобы избежать перегрузки внешнего API"
			},
			{
				"value": "c",
				"text": "Повторять запросы строго по расписанию (каждую минуту), чтобы равномерно распределить нагрузку"
			},
			{
				"value": "d",
				"text": "Всегда повторять сразу после ошибки, иначе можно упустить момент, когда API доступен"
			},
			{
				"value": "e",
				"text": "Я не уверен, зависит от требований к устойчивости и частоте ошибок"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 2,
			"d": 0,
			"e": 1
		}
	},
	{
		"id": "sys15",
		"category": "system_design",
		"type": "case",
		"question": "В архитектуре микросервисов появилась задача централизованного управления сетевыми коммуникациями: маршрутизация, TLS, ретраи, логирование и метрики. Какой подход будет наиболее эффективен при росте количества сервисов?",
		"options": [
			{
				"value": "a",
				"text": "Каждый сервис включает собственную реализацию всех необходимых функций: шифрование, повторные попытки, логирование. Это позволяет кастомизировать поведение под конкретную логику."
			},
			{
				"value": "b",
				"text": "Внедрить слой Service Mesh — специальный инфраструктурный компонент, который работает рядом с сервисами и берёт на себя ответственность за сетевые аспекты, включая политику доступа и телеметрию."
			},
			{
				"value": "c",
				"text": "Добавить отдельный API Gateway к каждому сервису. Это даст гибкость управления входящими запросами и контроль над доступом к каждому из них."
			},
			{
				"value": "d",
				"text": "Реализовать центральный маршрутный сервис, через который будут проходить все запросы между сервисами, что упростит трассировку и централизованный контроль."
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить — тема архитектуры сервисов пока новая для меня."
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 2,
			"d": 1,
			"e": 1
		}
	},
	{
		"id": "sys16",
		"category": "system_design",
		"type": "case",
		"question": "Вы разрабатываете критичную распределённую систему. В команде обсуждают, как заранее выявить слабые места в поведении системы при сбоях. Что из этого ближе всего к подходу Chaos Engineering?",
		"options": [
			{
				"value": "a",
				"text": "Настроить мониторинг и алерты, чтобы при сбое как можно быстрее реагировать вручную. Это позволит сократить время восстановления."
			},
			{
				"value": "b",
				"text": "Проводить плановые отключения компонентов системы в проде и анализировать поведение. Например, «случайно» выключить ноду или имитировать перегрузку API."
			},
			{
				"value": "c",
				"text": "Запускать нагрузочное тестирование в условиях высокой конкуренции за ресурсы и следить за изменением метрик производительности."
			},
			{
				"value": "d",
				"text": "Проводить code review и архитектурные комитеты, где заранее обсуждаются возможные точки отказа."
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить — не знаком с подходами тестирования отказоустойчивости."
			}
		],
		"weights": {
			"a": 1,
			"b": 5,
			"c": 2,
			"d": 1,
			"e": 1
		}
	},
	{
		"id": "sys17",
		"category": "system_design",
		"type": "case",
		"question": "Команда обсуждает использование Event Sourcing в новом сервисе управления заказами. Какое преимущество даёт этот подход?",
		"options": [
			{
				"value": "a",
				"text": "Упрощает миграцию на микросервисы — каждый сервис может хранить своё состояние в изолированной БД без событий"
			},
			{
				"value": "b",
				"text": "Позволяет сохранять и воспроизводить все изменения состояния через события, что делает систему трассируемой и пригодной для аудита"
			},
			{
				"value": "c",
				"text": "Позволяет упростить схему базы данных за счёт удаления исторических таблиц и хранения только текущего состояния"
			},
			{
				"value": "d",
				"text": "Реализует eventual consistency, потому что все события приходят в одном порядке в любой сервис"
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить — не совсем понимаю, в чём разница между обычным сохранением состояния и ивентами"
			}
		],
		"weights": {
			"a": 0,
			"b": 5,
			"c": 1,
			"d": 1,
			"e": 1
		}
	},
	{
		"id": "sys19",
		"category": "system_design",
		"type": "case",
		"question": "Вы разрабатываете систему учёта заказов в интернет-магазине. Бизнес хочет видеть: как формировался заказ, какие товары добавлялись или удалялись, как менялся адрес доставки, и когда заказ был оформлен. Какое решение лучше всего подходит под эти требования?",
		"options": [
			{
				"value": "a",
				"text": "Применить Event Sourcing — каждое действие пользователя (добавление товара, изменение адреса, оформление) фиксировать как событие. Это обеспечит полную историю изменений и возможность переигрывания."
			},
			{
				"value": "b",
				"text": "Хранить только финальное состояние заказа в таблице. В историю изменений можно не смотреть, главное — что заказ оформлен."
			},
			{
				"value": "c",
				"text": "Сделать отдельную таблицу «История действий», в которую вручную писать шаги пользователя. Это проще, чем Event Sourcing, и может подойти."
			},
			{
				"value": "d",
				"text": "Использовать JSON-столбец, куда складывать слепок заказа при каждом изменении. Потом можно будет посмотреть, как он менялся во времени."
			},
			{
				"value": "e",
				"text": "Затрудняюсь ответить. Не работал с подобными требованиями."
			}
		],
		"weights": {
			"a": 5,
			"b": 0,
			"c": 3,
			"d": 2,
			"e": 1
		}
	},
	{
		"id": "sys21",
		"category": "system_design",
		"type": "case",
		"question": "В интернет-магазине пользователи оформляют заказы, а менеджеры строят тяжёлые отчёты с агрегацией по всем заказам. С ростом количества заказов система начинает тормозить. Как можно архитектурно решить проблему?",
		"options": [
			{
				"value": "a",
				"text": "Перейти на подход CQRS — разделить модели команд и чтения: заказы записываются в одну модель, а отчёты читаются из другой, предагрегированной и оптимизированной под чтение"
			},
			{
				"value": "b",
				"text": "Добавить в микросервис слой GraphQL с возможностью агрегации — он справится с гибкими отчётами и снимет нагрузку"
			},
			{
				"value": "c",
				"text": "Настроить cron-задачу, которая будет раз в час выгружать заказы в CSV и класть в общий файловый архив для менеджеров"
			},
			{
				"value": "d",
				"text": "Реализовать всё через Redis Streams — он быстро работает с сообщениями и обеспечит высокую пропускную способность"
			},
			{
				"value": "e",
				"text": "Выделить отчёты в отдельный микросервис, но использовать ту же базу данных — это изолирует код, но не данные"
			},
			{
				"value": "f",
				"text": "Затрудняюсь ответить — пока не сталкивался с подобными архитектурными перегрузками"
			}
		],
		"weights": {
			"a": 5,
			"b": 1,
			"c": 2,
			"d": 0,
			"e": 3,
			"f": 1
		}
	},
	{
		"id": "sys22",
		"category": "system_design",
		"type": "case",
		"question": "Вы проектируете модель заказов в системе интернет-магазина. Как правильно подойти к выбору агрегатов, сущностей и value-объектов?",
		"options": [
			{
				"value": "a",
				"text": "Сделать каждый товар в заказе отдельным агрегатом — это обеспечит независимость обработки, особенно при возвратах"
			},
			{
				"value": "b",
				"text": "Выделить заказ как агрегат, содержащий товары как сущности, а адрес доставки и способ оплаты — как value objects, так как они не имеют собственной идентичности"
			},
			{
				"value": "c",
				"text": "Не использовать агрегаты и value objects — DDD не даёт пользы, если нет высоких требований к сложности домена"
			},
			{
				"value": "d",
				"text": "Затрудняюсь ответить — понимаю, что DDD мощная штука, но ещё не применял на практике"
			},
			{
				"value": "e",
				"text": "Хранить всё как value objects — это позволит упростить модель и избежать избыточной сложности с идентификаторами"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 0,
			"d": 1,
			"e": 1
		}
	},
	{
		"id": "sys23",
		"category": "system_design",
		"type": "case",
		"question": "У вас несколько клиентских приложений: мобильное, веб и виджет для стороннего сайта. Как организовать взаимодействие между ними и бэкендом?",
		"options": [
			{
				"value": "a",
				"text": "Сделать единый универсальный API для всех клиентов, чтобы избежать дублирования логики"
			},
			{
				"value": "b",
				"text": "Использовать отдельный BFF для каждого клиента — это позволит адаптировать API под особенности UX и уменьшить связанность"
			},
			{
				"value": "c",
				"text": "Позволить каждому клиенту обращаться напрямую к микросервисам — это даёт максимальную гибкость и уменьшает задержки"
			},
			{
				"value": "d",
				"text": "Затрудняюсь ответить — кажется, зависит от количества клиентов и различий в интерфейсе"
			},
			{
				"value": "e",
				"text": "Дублировать бизнес-логику на стороне клиентов, чтобы API остался максимально простым"
			}
		],
		"weights": {
			"a": 2,
			"b": 5,
			"c": 1,
			"d": 1,
			"e": 0
		}
	},
	{
		"id": "sys24",
		"category": "system_design",
		"type": "case",
		"question": "Вы интегрируете старую CRM-систему с новым модулем заказов, построенным по принципам DDD. Как избежать утечек модели и защитить домен от внешнего влияния?",
		"options": [
			{
				"value": "a",
				"text": "Создать Event Bus и просто ретранслировать события из CRM как есть, не трогая формат данных"
			},
			{
				"value": "b",
				"text": "Рассматривать модель CRM как Value Object и использовать ее напрямую, ведь Value Object не создают зависимости"
			},
			{
				"value": "c",
				"text": "Подключить старую CRM как внешний агрегат и обращаться к ней напрямую из доменной логики"
			},
			{
				"value": "d",
				"text": "Я затрудняюсь ответить — возможно, нужно провести отдельный анализ контекста и границ моделей"
			},
			{
				"value": "e",
				"text": "Использовать Anti-Corruption Layer: создать адаптеры, трансформирующие данные из внешней системы в нашу модель и наоборот"
			},
			{
				"value": "f",
				"text": "Обернуть CRM REST API в proxy-сервис и прокидывать все запросы через него, не меняя структуру"
			}
		],
		"weights": {
			"a": 1,
			"b": 0,
			"c": 0,
			"d": 1,
			"e": 5,
			"f": 2
		}
	},
	{
		"id": "sys25",
		"category": "system_design",
		"type": "case",
		"question": "Вы проектируете распределенную систему, где важны и производительность, и надежность. Вам нужно выбрать стратегию записи данных. Что повлияет на ваш выбор?",
		"options": [
			{
				"value": "a",
				"text": "Асинхронная запись с подтверждением от одной реплики увеличит производительность, но может привести к потере данных при сбое"
			},
			{
				"value": "b",
				"text": "Синхронная запись с quorum подтверждением повысит надёжность, но увеличит латентность записи"
			},
			{
				"value": "c",
				"text": "Выбор зависит от модели consistency в базе: если eventual consistency, достаточно ack от одного узла"
			},
			{
				"value": "d",
				"text": "Чтение только из лидера снизит шансы на неактуальные данные, но снизит масштабируемость чтений"
			},
			{
				"value": "e",
				"text": "Я не уверен, как это работает в распределенных системах. Надо почитать про CAP или PACELC."
			}
		],
		"weights": {
			"a": 3,
			"b": 5,
			"c": 2,
			"d": 2,
			"e": 0
		}
	},
	{
		"id": "sec1",
		"category": "security",
		"type": "practical",
		"question": "Как безопасно хранить API ключи сторонних сервисов?",
		"options": [
			{ 
				"value": "a", 
				"text": "Использование зашифрованных конфигурационных файлов с мастер-ключом в аппаратном модуле безопасности и ротацией при каждом развертывании" 
			},
			{
				"value": "b",
				"text": "Централизованное управление секретами (HashiCorp Vault/AWS KMS) с динамическими секретами, журналированием доступа и автоматическими политиками ротации"
			},
			{ 
				"value": "c", 
				"text": "Шифрование ключей в базе данных с использованием конвертного шифрования и доступом через роли управления идентификацией" 
			},
			{ 
				"value": "d", 
				"text": "Переменные окружения с шифрованием в состоянии покоя, строгим ролевым доступом и интеграцией с конвейером развертывания" 
			}
		],
		"weights": { "a": 1, "b": 5, "c": 3, "d": 1 }
	},
	{
		"id": "sys26",
		"category": "system_design",
		"type": "practical",
		"question": "Вам нужно спроектировать кеш для данных, которые редко обновляются, но часто читаются. Что предпочтительнее?",
		"options": [
			{
				"value": "a",
				"text": "Write-through cache — обновления сразу пишутся и в кеш, и в БД, гарантируя согласованность, но замедляя запись"
			},
			{
				"value": "b",
				"text": "Write-back cache — обновления пишутся только в кеш и синхронно сбрасываются в базу позже, повышая производительность, но увеличивая риск потери данных при сбое"
			},
			{
				"value": "c",
				"text": "Read-through cache — запросы на чтение сначала идут в кеш, а при промахе — в базу, удобно для стабильных данных"
			},
			{
				"value": "d",
				"text": "Ручное управление кешем на уровне кода даёт максимум контроля, но требует сложной логики и тестов"
			},
			{
				"value": "e",
				"text": "Я не знаю, как выбрать кеширующую стратегию — надо посмотреть, как ведут себя сами данные"
			}
		],
		"weights": {
			"a": 2,
			"b": 1,
			"c": 5,
			"d": 3,
			"e": 0
		}
	},
	{
    "id": "sec1",
    "category": "security",
    "type": "practical",
    "question": "Что из перечисленного является самой распространённой причиной уязвимостей в веб-приложениях?",
    "options": [
      {
        "value": "a",
        "text": "Неправильная настройка сервера — например, открытые порты или доступные для всех панели управления"
      },
      {
        "value": "b",
        "text": "Хранение секретов в коде — например, ключей доступа или паролей в репозитории"
      },
      {
        "value": "c",
        "text": "Отсутствие логирования — невозможно выявить атаки и реагировать"
      },
      {
        "value": "d",
        "text": "Невалидируемый пользовательский ввод, который может быть использован для атак, например, SQL-инъекций"
      },
      {
        "value": "e",
        "text": "Все перечисленное опасно, но одна из причин особенно критична"
      },
      {
        "value": "f",
        "text": "Я не знаю, скорее всего это зависит от конкретного приложения"
      }
    ],
    "weights": {
      "a": 1,
      "b": 2,
      "c": 1,
      "d": 5,
      "e": 3,
      "f": 0
    }
  },
  {
    "id": "sec2",
    "category": "security",
    "type": "case",
    "question": "Разработчик предлагает использовать localStorage для хранения access token. Как реагировать?",
    "options": [
      {
        "value": "a",
        "text": "Объясню, что localStorage уязвим для XSS, и access token лучше хранить в httpOnly cookie"
      },
      {
        "value": "b",
        "text": "Скажу, что можно, если применить Content Security Policy и шифровать токены"
      },
      {
        "value": "c",
        "text": "Соглашусь, ведь это проще всего реализовать на фронте"
      },
      {
        "value": "d",
        "text": "Предложу использовать sessionStorage — у него меньше риска утечки"
      },
      {
        "value": "e",
        "text": "Access token можно держать в памяти, а refresh в localStorage, если реализован токен ротации"
      },
      {
        "value": "f",
        "text": "Не уверен, наверное лучше спросить у security команды"
      }
    ],
    "weights": {
      "a": 5,
      "b": 2,
      "c": 0,
      "d": 2,
      "e": 3,
      "f": 1
    }
  },
  {
    "id": "sec3",
    "category": "security",
    "type": "case",
    "question": "Пользователь сообщил, что его JWT токен, по всей видимости, был украден. Ваши действия?",
    "options": [
      {
        "value": "a",
        "text": "Инвалидировать конкретный токен через blacklist (если реализован), выдать новый, проанализировать логи"
      },
      {
        "value": "b",
        "text": "Сменить secret и инвалидировать все токены — жёстко, но безопасно"
      },
      {
        "value": "c",
        "text": "Объяснить, что JWT stateless — надо просто подождать истечения срока действия"
      },
      {
        "value": "d",
        "text": "Внедрить rotation: короткоживущий access token + refresh token, чтобы можно было отзывать"
      },
      {
        "value": "e",
        "text": "Предложить временно перейти на cookie-based session и двуфакторную авторизацию"
      },
      {
        "value": "f",
        "text": "Запустить расследование, временно заблокировать пользователя и сообщить в security команду"
      }
    ],
    "weights": {
      "a": 4,
      "b": 3,
      "c": 1,
      "d": 5,
      "e": 2,
      "f": 3
    }
  },
  {
    "id": "sec4",
    "category": "security",
    "type": "case",
    "question": "В логах замечен запрос: /api/users?id=1' OR '1'='1. Что это и как реагировать?",
    "options": [
      {
        "value": "a",
        "text": "Это SQL-инъекция. Нужно перейти на параметризованные запросы или безопасный ORM"
      },
      {
        "value": "b",
        "text": "Можно экранировать спецсимволы, чтобы такие запросы не сработали"
      },
      {
        "value": "c",
        "text": "Проверить тип данных в параметре, например, ограничить только числа"
      },
      {
        "value": "d",
        "text": "Установить WAF и забанить этот IP при повторных попытках"
      },
      {
        "value": "e",
        "text": "Ничего страшного — запрос просто странный, но безвредный"
      },
      {
        "value": "f",
        "text": "Убрать пользовательские параметры вообще — пусть все через POST идут"
      }
    ],
    "weights": {
      "a": 5,
      "b": 2,
      "c": 3,
      "d": 2,
      "e": 0,
      "f": 1
    }
  },
  {
    "id": "sec5",
    "category": "security",
    "type": "practical",
    "question": "Какой подход сейчас считается наиболее безопасным для хранения паролей пользователей?",
    "options": [
      {
        "value": "a",
        "text": "Хранить хеши с использованием bcrypt (12+), Argon2id или PBKDF2 в зависимости от контекста"
      },
      {
        "value": "b",
        "text": "SHA-256 с солью — всё ещё достаточно безопасен и простой в реализации"
      },
      {
        "value": "c",
        "text": "Хранить зашифрованные пароли, чтобы при утере их можно было восстановить"
      },
      {
        "value": "d",
        "text": "OAuth от Google и Facebook — вообще не надо хранить свои пароли"
      },
      {
        "value": "e",
        "text": "Двойной MD5 с солями — защищает от большинства атак словарём"
      },
      {
        "value": "f",
        "text": "Прятать пароли в отдельной таблице с ограниченным доступом в базе"
      }
    ],
    "weights": {
      "a": 5,
      "b": 2,
      "c": 0,
      "d": 3,
      "e": 0,
      "f": 1
    }
  },
	{
		"id": "analytical1",
		"category": "analytical",
		"type": "case",
		"question": "Конверсия упала с 5% до 2% после релиза. Как найти причину?",
		"options": [
			{ 
				"value": "a", 
				"text": "Провести анализ первопричин через технический разбор изменений в релизе и корреляцию с метриками производительности системы" 
			},
			{
				"value": "b",
				"text": "Когортный анализ по сегментам пользователей, разбивка воронки по шагам, откат A/B теста на выборке, анализ записей сессий, корреляция с метриками производительности"
			},
			{ 
				"value": "c", 
				"text": "Немедленный откат релиза с последующим поэтапным включением функций для изоляции проблемного компонента системы" 
			},
			{ 
				"value": "d", 
				"text": "Статистический анализ для проверки значимости изменения конверсии с учетом сезонности и внешних факторов влияния" 
			}
		],
		"weights": { "a": 2, "b": 5, "c": 3, "d": 1 }
	},
	{
		"id": "analytical2",
		"category": "analytical",
		"type": "case",
		"question": "Вы анализируете статистику отказов пользователей при регистрации. Обнаружили, что после ввода email многие покидают форму. Какое из объяснений наиболее логично и требует первичной проверки?",
		"options": [
			{
				"value": "a",
				"text": "Проблема может быть в следующем поле формы — например, требовании придумать сложный пароль без подсказки. Нужно проверить поведение на следующем шаге"
			},
			{
				"value": "b",
				"text": "Пользователи не любят делиться email — возможно, стоит добавить галочку 'Не буду получать рассылку'"
			},
			{
				"value": "c",
				"text": "Скорее всего, баг в валидации email — например, она слишком строгая. Нужно проверить консоль"
			},
			{
				"value": "d",
				"text": "Это нормальное поведение, 80% пользователей всегда отваливаются при регистрации, ничего делать не надо"
			},
			{
				"value": "e",
				"text": "Я не уверен, с чего начать, нужно поговорить с UX-аналитиком или дизайнером"
			}
		],
		"weights": {
			"a": 5,
			"b": 3,
			"c": 3,
			"d": 0,
			"e": 2
		}
	},
	{
		"id": "analytical3",
		"category": "analytical",
		"type": "practical",
		"question": "Нужно оценить влияние новой фичи. Какие метрики отслеживать?",
		"options": [
			{ 
				"value": "a", 
				"text": "Воронка внедрения функции, коэффициент вовлеченности, время до первой ценности и влияние на ежедневных и ежемесячных активных пользователей" 
			},
			{
				"value": "b",
				"text": "Фреймворк HEART (Счастье, Вовлеченность, Внедрение, Удержание, Успешность задач) с опережающими и отстающими индикаторами и когортным удержанием"
			},
			{ 
				"value": "c", 
				"text": "Количественные метрики использования функции, качественная обратная связь через индекс лояльности клиентов и корреляция с бизнес-показателями" 
			},
			{ 
				"value": "d", 
				"text": "A/B тестирование с контрольной группой, проверка статистической значимости результатов и долгосрочный мониторинг удержания пользователей" 
			}
		],
		"weights": { "a": 2, "b": 5, "c": 1, "d": 1 }
	},
	{
    "id": "analytical4",
    "category": "analytical",
    "type": "practical",
    "question": "После недавнего релиза пользователи начали жаловаться на резкое замедление работы системы. Как вы бы подошли к поиску узкого места в производительности?",
    "options": [
      { "value": "a", "text": "Сравнить метрики работы ключевых компонентов до и после релиза, чтобы локализовать источник деградации" },
      { "value": "b", "text": "Подключить APM-систему, проанализировать медленные запросы, запустить профилировку и распределённую трассировку" },
      { "value": "c", "text": "Откатить весь релиз и повторно раскатывать каждую фичу по очереди, пока не проявится проблема" },
      { "value": "d", "text": "Проверить состояние базы данных — чаще всего причина в ней" },
      { "value": "e", "text": "Запустить нагрузочное тестирование в тестовой среде, чтобы воспроизвести и изолировать проблему" },
      { "value": "f", "text": "Добавить новые сервера — может быть, просто не хватает мощности" },
      { "value": "g", "text": "Посмотреть diff кода: искать N+1, пропущенные индексы, тяжёлые циклы" },
      { "value": "h", "text": "Поспрашивать разработчиков, что именно менялось" }
    ],
    "weights": { "a": 3, "b": 5, "c": 2, "d": 1, "e": 4, "f": 0, "g": 4, "h": 1 }
  },
  {
    "id": "analytical5",
    "category": "analytical",
    "type": "case",
    "question": "Два микросервиса обмениваются сообщениями, но периодически теряются данные. Команды обвиняют друг друга. Как подойти к выяснению причин потери данных?",
    "options": [
      { "value": "a", "text": "Настроить распределённую трассировку, чтобы отследить путь каждого события от начала до конца" },
      { "value": "b", "text": "Добавить Correlation ID в каждый запрос, структурировать логи, проставить таймстемпы и выстроить таймлайн событий" },
      { "value": "c", "text": "Воспроизвести кейс в тестовой среде с максимальным логированием" },
      { "value": "d", "text": "Проверить брокер сообщений: нет ли в очереди потерянных или необработанных событий" },
      { "value": "e", "text": "Заменить асинхронную коммуникацию на синхронную для надёжности" },
      { "value": "f", "text": "Сравнить объёмы отправленных и полученных сообщений за одинаковый интервал" },
      { "value": "g", "text": "Внедрить Event Sourcing — это исключит потери в будущем" },
      { "value": "h", "text": "Созвать команды на встречу и обсудить, кто виноват" }
    ],
    "weights": { "a": 4, "b": 5, "c": 3, "d": 4, "e": 0, "f": 3, "g": 1, "h": 0 }
  },
  {
    "id": "analytical6",
    "category": "analytical",
    "type": "practical",
    "question": "Вы разрабатываете новую систему, и нужно определиться: использовать SQL или NoSQL? Как вы бы провели анализ для принятия этого решения?",
    "options": [
      { "value": "a", "text": "Оценю характер доступа к данным, требования к консистентности, объёмы хранения и сценарии масштабирования" },
      { "value": "b", "text": "Проанализирую через призму CAP-теоремы, сравню ACID и BASE, изучу типы запросов, формат данных и общую стоимость владения" },
      { "value": "c", "text": "Возьму NoSQL — он всегда быстрее, особенно с большими объёмами" },
      { "value": "d", "text": "Построю прототипы на обеих СУБД с реальными сценариями и нагрузками, затем сравню" },
      { "value": "e", "text": "Посмотрю, что используют большие компании типа Google и Facebook" },
      { "value": "f", "text": "Проанализирую стек и опыт нашей команды — важно, чтобы могли поддерживать" },
      { "value": "g", "text": "Выберу PostgreSQL — он может и транзакции, и JSON, и масштабируется" },
      { "value": "h", "text": "Сделаю гибрид: SQL для критичных транзакций, NoSQL для логов и аналитики" }
    ],
    "weights": { "a": 4, "b": 5, "c": 0, "d": 4, "e": 1, "f": 3, "g": 2, "h": 3 }
  },
  {
    "id": "analytical7",
    "category": "analytical",
    "type": "case",
    "question": "Бизнес заметил, что данные в отчётах из разных систем не совпадают. Как вы бы подошли к решению этой проблемы?",
    "options": [
      { "value": "a", "text": "Построю карту потоков данных (data lineage), чтобы понять, как и откуда информация попадает в отчёты" },
      { "value": "b", "text": "Проверю ETL-процессы, добавлю валидации на каждом этапе, введу сверку данных и выберу эталонный источник" },
      { "value": "c", "text": "Скажу использовать только мою систему — она самая надёжная" },
      { "value": "d", "text": "Сравню формулы расчёта ключевых метрик — может, в них дело" },
      { "value": "e", "text": "Проверю агрегации и временные зоны — это частые причины расхождений" },
      { "value": "f", "text": "Создам централизованное хранилище, чтобы исключить дублирование и расхождения" },
      { "value": "g", "text": "Скажу, что расхождения — это норма в распределённых системах" },
      { "value": "h", "text": "Решу внедрить блокчейн для защиты целостности данных" }
    ],
    "weights": { "a": 4, "b": 5, "c": 0, "d": 3, "e": 4, "f": 2, "g": 0, "h": 0 }
  },
  {
    "id": "analytical8",
    "category": "analytical",
    "type": "practical",
    "question": "Вам поручили оценить готовность старой системы к миграции в облако. Какие шаги вы предпримете?",
    "options": [
      { "value": "a", "text": "Анализ архитектуры: состояние зависимостей, наличие stateful компонентов, latency, регуляторика, объёмы данных" },
      { "value": "b", "text": "Применю модель 6R: Rehost, Refactor, Revise, Rebuild, Replace, Retire. Посчитаю затраты и риски, набросаю roadmap" },
      { "value": "c", "text": "Сделаю lift-and-shift: просто перенесу всё на виртуалки и посмотрю" },
      { "value": "d", "text": "Если есть контейнеры — значит, можно мигрировать. Всё готово" },
      { "value": "e", "text": "Проведу анализ технического долга и оценю, что потребуется изменить под cloud-native" },
      { "value": "f", "text": "Выделю один малозначимый компонент и мигрирую его как пилот" },
      { "value": "g", "text": "Скажу, что переписывать проще — старое трогать не надо" },
      { "value": "h", "text": "Напишу всем вендорам облаков — пусть они подскажут, готова ли система" },
      { "value": "i", "text": "Затрудняюсь ответить — с облаками не работал" }
    ],
    "weights": { "a": 4, "b": 5, "c": 1, "d": 0, "e": 4, "f": 3, "g": 0, "h": 1, "i": 0 }
  },
	{
		"id": "comm1",
		"category": "communication",
		"type": "case",
		"question": "Продукт-оунер требует срочную реализацию новой фичи — «на этой неделе». Команда же на грани выгорания, а под капотом — технический долг, который уже приводит к багам. Как поступите?",
		"options": [
			{
				"value": "a",
				"text": "Покиваю, возьмем в спринт. Главное — не спорить, потом как-нибудь разберёмся"
			},
			{
				"value": "b",
				"text": "Предложу MVP с ограниченным функционалом, а параллельно начну рефакторить самый критичный модуль"
			},
			{
				"value": "c",
				"text": "Соберу визуализацию последствий: графики инцидентов, рост времени отклика, зависимость между долгом и фичей. Покажу, что техдолг уже мешает доставлять"
			},
			{
				"value": "d",
				"text": "Запланирую реализацию фичи с временным решением и 'флажком' выключения, чтобы потом спокойно всё переписать"
			},
			{
				"value": "e",
				"text": "Эскалирую в архитектурный совет или CTO, чтобы получить приоритет сверху"
			},
			{
				"value": "f",
				"text": "Я не знаю, как вести такие диалоги — пусть решают менеджеры"
			}
		],
		"weights": {
			"a": 0,
			"b": 3,
			"c": 5,
			"d": 2,
			"e": 3,
			"f": 1
		}
	},
	{
		"id": "comm2",
		"category": "communication",
		"type": "practical",
		"question": "Вы проводите встречу по сбору требований. Хотите получить не только список хотелок, но и понять мотивацию и ограничения. Как вы подойдете к встрече?",
		"options": [
			{
				"value": "a",
				"text": "Создам чёткую повестку, отправлю материалы заранее, буду документировать в процессе, использовать визуальные схемы и в конце уточню RACI-матрицу для следующих шагов"
			},
			{
				"value": "b",
				"text": "Ограничусь стандартным набором вопросов: что нужно, когда и зачем. Остальное — лишнее"
			},
			{
				"value": "c",
				"text": "Проведу серию коротких 1:1 интервью с ключевыми стейкхолдерами, после чего сведу инсайты и потребности через affinity mapping"
			},
			{
				"value": "d",
				"text": "Выберу формат дизайн-мышления: эмпатия, путь пользователя, быстрые прототипы — всё в одной сессии"
			},
			{
				"value": "e",
				"text": "Попрошу бизнес всё расписать в Confluence, чтобы не тратить время на встречи"
			},
			{
				"value": "f",
				"text": "Я только начинаю — не знаю, какой формат подходит. Надо посмотреть, как делают другие"
			}
		],
		"weights": {
			"a": 5,
			"b": 0,
			"c": 4,
			"d": 3,
			"e": 1,
			"f": 2
		}
	},
	{
		"id": "comm3",
		"category": "communication",
		"type": "practical",
		"question": "К вам подходит джуниор с задачей, в которой запутался. Вы загружены — брифинг через 15 минут, дедлайны горят. Как поступите, чтобы не сгореть самому и не оставить его в одиночестве?",
		"options": [
			{
				"value": "a",
				"text": "Жёстко скажу, что занят и пусть сам разбирается — это закаляет характер и учит самостоятельности"
			},
			{
				"value": "b",
				"text": "Открою таймер на 10 минут: вместе разберём формулировку задачи, подскажу, где копать, и помогу сформировать уточняющие вопросы"
			},
			{
				"value": "c",
				"text": "Перекину его к коллеге, который сейчас менее загружен — не идеально, но быстрее"
			},
			{
				"value": "d",
				"text": "Быстро сам сделаю его задачу, чтобы он не мешал и всё шло по графику"
			},
			{
				"value": "e",
				"text": "Скажу: «Сейчас не могу, но давай созвонимся через час, когда освобожусь»"
			},
			{
				"value": "f",
				"text": "Проигнорирую — если реально нужно, он снова напишет или найдёт другого"
			}
		],
		"weights": { "a": 1, "b": 5, "c": 3, "d": 0, "e": 4, "f": 0 }
	},
	{
		"id": "comm4",
		"category": "communication",
		"type": "case",
		"question": "Во время утреннего стендапа один из разработчиков уходит в подробности реализации на 10 минут. Команда скучает, хмурится. Что делаете?",
		"options": [
			{
				"value": "a",
				"text": "Мягко перебиваю: «Давайте придерживаться формата: что сделал, что планируешь, и есть ли блокеры»"
			},
			{
				"value": "b",
				"text": "Даю договорить, но после митинга пишу в личку с пояснением, что стендап — не техразбор"
			},
			{
				"value": "c",
				"text": "Слушаю с интересом — вдруг это полезно команде и поднимет техградус обсуждения"
			},
			{
				"value": "d",
				"text": "Предлагаю после созвониться отдельно тем, кому это реально интересно, и двинуться дальше"
			},
			{
				"value": "e",
				"text": "Выключаю звук, параллельно читаю почту — пусть болтает, всё равно это не про меня"
			},
			{
				"value": "f",
				"text": "Пишу в общий чат: «Ребят, стендап немного затянулся, давайте кратко»"
			},
			{
				"value": "g",
				"text": "Таймтрекер включён — в конце покажу, кто сколько говорил, чтобы подтолкнуть к саморефлексии"
			}
		],
		"weights": { "a": 4, "b": 3, "c": 1, "d": 5, "e": 0, "f": 1, "g": 2 }
	},
	{
		"id": "comm5",
		"category": "communication",
		"type": "case",
		"question": "PM просит вас дать оценку задачи. Но с формулировкой беда: требования туманные, описание на уровне 'что-то сделать', UX — в воздухе. Какой подход выберете?",
		"options": [
			{
				"value": "a",
				"text": "Накину большую оценку с запасом — пусть будет с запасом, чтобы потом не попасть"
			},
			{
				"value": "b",
				"text": "Предложу сначала провести груминг: уточнить требования, сценарии, обсудить граничные случаи — и уже потом оценивать"
			},
			{
				"value": "c",
				"text": "Прямо скажу: без нормального ТЗ даже пытаться не буду, это неадекватно"
			},
			{
				"value": "d",
				"text": "Сделаю диапазон от минимума до максимума и явно проговорю assumptions"
			},
			{
				"value": "e",
				"text": "Скажу '2 недели', как всегда — потом уточним по ходу дела"
			},
			{
				"value": "f",
				"text": "Предложу сделать короткий spike-ресерч на день-два, чтобы оценить объём и риски"
			},
			{
				"value": "g",
				"text": "Оценю в story points — так хоть понятно, насколько это сложно, без привязки ко времени"
			},
			{
				"value": "h",
				"text": "Скажу: я технарь, а не телепат — оценивать без данных бессмысленно"
			}
		],
		"weights": { "a": 2, "b": 5, "c": 1, "d": 4, "e": 0, "f": 4, "g": 3, "h": 0 }
	},
	{
		"id": "comm6",
		"category": "communication",
		"type": "practical",
		"question": "Два важных стейкхолдера приходят с требованиями, которые друг другу противоречат. Один хочет одно, второй — прямо противоположное. Как будете разруливать?",
		"options": [
			{
				"value": "a",
				"text": "Сделаю по тому, кто выше по иерархии — проще и безопаснее"
			},
			{
				"value": "b",
				"text": "Созову совместную встречу, чтобы они сами договорились, а я помог зафиксировать общее решение письменно"
			},
			{
				"value": "c",
				"text": "Сделаю так, как считаю технически правильным — моя зона ответственности"
			},
			{
				"value": "d",
				"text": "Эскалирую их общему начальству — пусть сверху разруливают"
			},
			{
				"value": "e",
				"text": "Покажу, как расхождения влияют на сроки, стоимость и риски — пусть сами приоритеты расставляют"
			},
			{
				"value": "f",
				"text": "Сделаю оба варианта за флагами, чтобы потом выбрали"
			},
			{
				"value": "g",
				"text": "Пойму, какие цели у каждого, и предложу компромисс, который решает обе задачи"
			},
			{
				"value": "h",
				"text": "Это их проблема — я разработчик, не медиатор"
			},
			{
				"value": "i",
				"text": "Специально не буду брать задачу, пока они не договорятся"
			}
		],
		"weights": { "a": 0, "b": 5, "c": 0, "d": 2, "e": 4, "f": 3, "g": 5, "h": 0, "i": 0 }
	},
	{
		"id": "comm7",
		"category": "communication",
		"type": "case",
		"question": "Во время важной презентации для инвесторов неожиданно всплывает критический баг на проде. Всё работает некорректно, но пока заметили только вы. Как поступите?",
		"options": [
			{
				"value": "a",
				"text": "Попробую тихо починить прямо сейчас, не привлекая внимания — презентация важнее"
			},
			{
				"value": "b",
				"text": "Сообщу техлиду, оценим риски и решим: чинить сейчас или после. Главное — с холодной головой"
			},
			{
				"value": "c",
				"text": "Паникую и пишу в общий Slack: «Всё сломалось!»"
			},
			{
				"value": "d",
				"text": "Запишу баг, подниму RCA и план коммуникации, но только после презентации"
			},
			{
				"value": "e",
				"text": "Сразу завожу инцидент по регламенту, зову incident commander, начинаем реагировать по процедуре"
			},
			{
				"value": "f",
				"text": "Откатываю последний деплой, авось поможет — это быстрее всего"
			},
			{
				"value": "g",
				"text": "Сообщаю PM, чтобы он принял решение — он отвечает за внешнюю коммуникацию"
			},
			{
				"value": "h",
				"text": "Пусть кто-то другой решает — я не хочу брать ответственность в такой момент"
			}
		],
		"weights": { "a": 1, "b": 5, "c": 0, "d": 3, "e": 4, "f": 1, "g": 4, "h": 0 }
	},
	{
		"id": "comm8",
		"category": "communication",
		"type": "practical",
		"question": "У вас на руках мощное техническое решение, которое действительно улучшит систему. Но руководство — не технари. Как донесёте идею, чтобы вас не просто выслушали, а реально поддержали?",
		"options": [
			{
				"value": "a",
				"text": "Начну с архитектурных диаграмм и технической сложности, чтобы показать масштаб и продвинутость"
			},
			{
				"value": "b",
				"text": "Начну с бизнес-выгоды: какие метрики улучшим, какие риски сейчас есть, какой подход предлагаем, сколько это даст ROI и когда"
			},
			{
				"value": "c",
				"text": "Принесу распечатки красивых диаграмм — пусть наглядность работает"
			},
			{
				"value": "d",
				"text": "Объясню аналогиями — сравню с чем-то из реального мира, чтобы проще восприняли концепцию"
			},
			{
				"value": "e",
				"text": "Сделаю one-pager с выводами: проблема, решение, эффект, стоимость — чётко и лаконично"
			},
			{
				"value": "f",
				"text": "Перекину задачу техлиду — он это умеет лучше рассказывать, я про техническую часть"
			},
			{
				"value": "g",
				"text": "Покажу, как конкуренты это уже реализовали и какие у них результаты — немного давления не повредит"
			},
			{
				"value": "h",
				"text": "Покажу простые цифры: сколько времени и денег это экономит, какие потери без внедрения"
			},
			{
				"value": "i",
				"text": "Ожидаю, что руководство доверяет команде и не требует объяснений — просто нужно делать"
			}
		],
		"weights": { "a": 0, "b": 5, "c": 1, "d": 4, "e": 4, "f": 0, "g": 3, "h": 4, "i": 0 }
	},
	{
		"id": "comm9",
		"category": "communication",
		"type": "case",
		"question": "Вендор прислал предложение по интеграции, но вы видите в нём серьёзные технические проблемы. Ваши следующие шаги?",
		"options": [
			{
				"value": "a",
				"text": "Просто скажу: 'Это плохое решение, делаем по-нашему'"
			},
			{
				"value": "b",
				"text": "Сделаю структурированный фидбек: что хорошо, что вызывает сомнения, конкретные примеры, уточняющие вопросы, возможные улучшения"
			},
			{
				"value": "c",
				"text": "Игнорирую — если вендор слабый, обсуждать нечего"
			},
			{
				"value": "d",
				"text": "Организую техническую сессию с их архитектором, чтобы на уровне диаграмм понять, в чём расхождения"
			},
			{
				"value": "e",
				"text": "Попрошу подготовить рабочий прототип (POC), чтобы убедиться в жизнеспособности спорных моментов"
			},
			{
				"value": "f",
				"text": "Скажу, что нужно больше времени на анализ — пусть подождут"
			},
			{
				"value": "g",
				"text": "Скину им список из 50 уточняющих вопросов — если хотят работать, пусть отвечают"
			},
			{
				"value": "h",
				"text": "Предложу рассмотреть альтернативного вендора, с которым уже есть опыт"
			},
			{
				"value": "i",
				"text": "Решение не на мне — менеджмент пусть разбирается, кого выбирать"
			}
		],
		"weights": { "a": 0, "b": 5, "c": 0, "d": 4, "e": 4, "f": 2, "g": 1, "h": 1, "i": 0 }
	},
	{
		"id": "comm10",
		"category": "communication",
		"type": "practical",
		"question": "Команда скептически относится к новой технологии, которую вы хотите внедрить: опасаются переучивания, нестабильности и потери времени. Как будете убеждать?",
		"options": [
			{
				"value": "a",
				"text": "Скажу: 'Решение принято, внедряем. Вопросов не будет'"
			},
			{
				"value": "b",
				"text": "Проведу воркшоп: покажу плюсы и минусы, сделаем пилот, замерим результат и внедрим по шагам"
			},
			{
				"value": "c",
				"text": "Покажу список топовых компаний, которые используют эту технологию — сработает как социальное доказательство"
			},
			{
				"value": "d",
				"text": "Найду энтузиастов в команде, которые хотят попробовать — и начнём с них"
			},
			{
				"value": "e",
				"text": "Организую обучение и менторство, чтобы снизить страх и порог входа"
			},
			{
				"value": "f",
				"text": "Если команда не готова — не будем давить. Значит, ещё не время"
			},
			{
				"value": "g",
				"text": "Покажу конкретно, какие их текущие боли решает эта технология"
			},
			{
				"value": "h",
				"text": "Подожду — со временем сами захотят, если идея хорошая"
			},
			{
				"value": "i",
				"text": "Начну использовать её сам в своих задачах и покажу результат — как пример"
			}
		],
		"weights": { "a": 0, "b": 5, "c": 1, "d": 4, "e": 4, "f": 1, "g": 5, "h": 0, "i": 3 }
	},
	{
		"id": "comm11",
		"category": "communication",
		"type": "case",
		"question": "Во время важной презентации для инвесторов внезапно обнаруживается критичный баг в проде: сервис не отвечает, часть функционала отвалилась. Что вы делаете в этот момент?",
		"options": [
			{
				"value": "a",
				"text": "Молча чиню, не сообщая никому — главное, чтобы презентация прошла гладко"
			},
			{
				"value": "b",
				"text": "Сообщу техлиду, быстро оценим масштаб ущерба, определим последствия и решим, как правильно коммуницировать"
			},
			{
				"value": "c",
				"text": "Паникую и пишу в общий чат: 'У нас всё сломалось!'"
			},
			{
				"value": "d",
				"text": "Примусь составлять RCA-документ и антикризисный план — но займусь этим после презентации"
			},
			{
				"value": "e",
				"text": "Запущу официальный процесс инцидента: заведу карточку, назначу ответственного, начнём разбор"
			},
			{
				"value": "f",
				"text": "Сразу же откатываю последний релиз — авось поможет"
			},
			{
				"value": "g",
				"text": "Сообщаю PM и предлагаю ему принять решение о внешней коммуникации — он ближе к инвесторам"
			},
			{
				"value": "h",
				"text": "Это выше моей ответственности — не моя зона влияния"
			}
		],
		"weights": { "a": 1, "b": 5, "c": 0, "d": 3, "e": 4, "f": 1, "g": 4, "h": 0 }
	},
	{
		"id": "comm12",
		"category": "communication",
		"type": "case",
		"question": "После серьёзного инцидента проводится post-mortem. Встреча начинается с взаимных обвинений: разработка винит DevOps, DevOps обвиняет разработчиков. В комнате нарастает напряжение. Как действуете?",
		"options": [
			{
				"value": "a",
				"text": "Пытаюсь определить, кто виноват на самом деле — и донести до всех, чтобы такого не повторялось"
			},
			{
				"value": "b",
				"text": "Направляю встречу в духе blameless-культуры: смотрим не кто виноват, а почему так получилось — фокус на системных причинах, а не на людях"
			},
			{
				"value": "c",
				"text": "Прошу обе стороны на время разойтись по отдельным сессионкам, чтобы потом спокойно обсудить"
			},
			{
				"value": "d",
				"text": "Говорю: 'Виноваты оба. Нужно работать лучше, коллеги.'"
			},
			{
				"value": "e",
				"text": "Использую технику '5 почему', чтобы докопаться до истинных корней инцидента и не дать разговору скатиться в эмоции"
			},
			{
				"value": "f",
				"text": "Отменяю встречу — с таким уровнем напряжения конструктив всё равно невозможен"
			},
			{
				"value": "g",
				"text": "Готовлю все факты и хронологию заранее, чтобы задавать тон дискуссии на основе данных, а не эмоций"
			},
			{
				"value": "h",
				"text": "Зову внешнего фасилитатора или техдиректора, чтобы взять контроль над ситуацией"
			},
			{
				"value": "i",
				"text": "Не вмешиваюсь — я техлид, а не психолог, пусть сами разбираются"
			},
			{
				"value": "j",
				"text": "Фокусирую внимание всех не на том, что уже произошло, а на конкретных превентивных мерах на будущее"
			}
		],
		"weights": { "a": 0, "b": 5, "c": 1, "d": 0, "e": 5, "f": 0, "g": 4, "h": 2, "i": 0, "j": 3 }
	}
]